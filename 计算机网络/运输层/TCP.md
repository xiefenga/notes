# 报文结构

![](http://oss.xiefeng.tech/img/20210802104934.jpg)

**RST** 标志字段代表该报文是一个特殊的重置报文，即当客户端请求没有监听的端口时服务器会返回该报文。

当服务器接收到没有进行监听的 UDP 端口报文时，则会给客户端发送一个特殊的 IDMP 数据报。

**最大报文段长度（MSS）：** MSS 保证一个 TCP 报文段加上 TCP/IP 首部能够适合链路层帧，TCP/IP 首部通常为 40 字节，MTU = MSS + 40

# 可靠数据传输

TCP 的可靠数据传输确保了数据是无损坏、无间隙、非冗余、按序到达的。

## 序号和确认号

TCP 将数据看成一个无结构的、有序的**字节流**。

一个报文段的序号是该报文段首字节的字节流编号，确认号是期望收到的下一个字节的序号。

TCP 采用**累计确认**机制，即收到一个 ACK 则表示前面所有的字节都成功接收。

当 TCP 接收方接受方接收到失序报文时，RFC 并没有做明确的规定，此时有两种选择：

1. 丢弃所有失序到达的报文
2. 缓存失序到达的报文，并等待缺少的字节到达再一起提交给上层应用程序

在实践中采用第二种选择，对于带宽的利用更为有效。

## 超时时长

TCP 估计发送方和接收方之间的往返时间（RTT），采用加权平均值：

TCP 在某一个时刻做一次 `SampleRTT` 测量，并维持一个均值 `EstimatedRTT`：

$EstimatedRTT = (1 - α)* EstimatedRTT + α*SampleRTT$（α 的推荐值为 0.125）

RTT 偏差 DevRTT，用于估算 SampleRTT 偏离 EstimatedRTT 的程度：

$DevRTT = (1-β) * DevRTT * | SampleRTT - EstimatedRTT |$（β 的推荐值为 0.25）

重传的时间间隔计算公式：$TimeoutInterval = EstimatedRTT + 4 * DevRTT$

初始的时间间隔为 1s，当出现超时后时间间隔加倍，当收到报文段时通过公式更新计时间隔的值。

## 定时器

TCP 采用单一的重传定时器，可以将定时器和最早的未被确认的报文段向关联。

1. 当 TCP 收到上层传递的数据并且当前没有启动定时器的情况，发送报文段并启动定时器
2. 当定时器超时，重传具有最小序号但仍未应答的报文段
3. 当收到未被确认的报文的 ACK 时，如果此时由未被确认的报文段，需要重启定时器

TCP 既不是 GBN，也不是 SR，更像是两者的优点的综合。

# 连接管理

## 三次握手

- 客户端 TCP 首先向服务器发送一个特殊的 TCP 报文段，报文段中的SYN比特为1，序号随机初始（`clint_isn`），这个报文段叫**SYN报文段**
- 服务器接收到 SYN 报文段，为该连接分配TCP缓存和变量，返回一个 SYN 比特为1，确认号为`clint_isn + 1`，序号也随机初始（`serve_isn`）的**SYNACK报文段**
- 客户端收到 AYNACK 报文段，客户端也分配缓存和变量，客户端则发送一个确认的报文段，该 SYN 比特为 0，并且这个阶段是可以携带数据的

## 四次挥手

- 客户端 TCP 发送一个特殊的报文段，FIN 比特为1
- 服务器返回 ACK 报文
- 服务器发送 FIN 比特为1的报文段
- 客户端返会 ACK 报文，并等待 2MSL 之后关闭 socket

**四次挥手的原因**

当服务端收到 FIN 报文时，很可能还有数据需要继续发送不能立即关闭 socket，所以只能先回复一个 ACK。只有等到服务端所有的报文都发送完了，才能发送 FIN 报文。

**等待 2MSL 的原因**

MSL：Maximum Segment Lifetime，最长报文段寿命，它是任何报文在网络上存在的最长时间，超过这个时间报文将被丢弃。

- 保证客户端发送的最后一个ACK报文段能够到达服务端
	- 最后一个 ACK 报文段有可能丢失，服务端超时重传 FIN 报文段，而客户端能在 2MSL 时间内收到这个重传的报文段并重传一次确认，重新启动 2MSL 计时器，最后客户端和服务端都进入到 CLOSED 状态。
	- 若客户端在 TIME_WAIT 状态不等待一段时间，而是发送完 ACK 后立即释放连接，则无法收到服务端重传的 FIN，所以不会再发送一次确认报文段，则服务端无法正常进入到 CLOSED 状态。
- 防止已失效的连接请求报文段出现在本连接中
	- 客户端在发送完最后一个 ACK 段后再经过2MSL，本连接所产生的所有报文段都从网络中消失
	- 这个TCP连接在2MSL等待期间，不会出现具有相同四元组的连接，只有 2MSL 结束后才会出现
	- 下一个新的具有相同四元组的连接中不会出现之前连接的报文段

## SYN攻击

SYN 洪泛攻击是 TCP 连接最为经典的 Dos 攻击是。

当服务器接收到客户端发来的 SYN 报文后，会为该 TCP 连接分配资源。

攻击者对服务器发送大量的 SYN 报文段，而不完成第三次的握手，则会导致服务器为这些半开的连接分配了大量的资源，导致服务器的连接资源被消耗殆尽。

## 状态变迁

### 握手阶段

对于服务端 TCP：

1. 当程序开始监听端口，TCP 从 CLOSED 状态变为 LISTEN 状态
2. 当接收到某个客户端发来的 SYN 报文，回一个 ACK + SYN，并进入 SYN_RECEIVED 状态
3. 收到客户端的 ACK 后，进入 ESTABLISHED 状态

对于客户端 TCP：

1. 当某个程序需要发送请求，则先发送 SYN 报文进行连接，状态由 CLOSED 变为 SYN_SENT 状态
2. 当收到服务器的 ACK + SYN 后，回一个 ACK，进入 ESTABLISHED 状态 

![](http://oss.xiefeng.tech/img/20210801134804.png)

### 挥手阶段

假设客户应用程序发起关闭，对于客户端来说：

1. 客户端 TCP 发送一个 FIN 比特设为 1 的报文，进入 FIN_WAIT_1 的状态
2. 收到服务器的 ACK 报文，进入 FIN_WAIT_2 状态
3. 收到服务器的 FIN 报文，回一个 ACK，并进入 TIME_WAIT 状态
4. 等待一段时间，进入 CLOSED 状态

对服务端来说：

1. 收到客户端发来的 FIN 报文，并回复一个 ACK，进入 CLOSE_WAIT 状态
2. 当服务器也要需要断开时，发送一个 FIN 报文，进入 LAST_ACK 状态
3. 接收到客户端发来的 ACK 时，进入 CLOSED 状态

![](http://oss.xiefeng.tech/img/20210801134810.png)

TIME_WAIT 状态允许当对服务器 FIN 报文的 ACK 丢失时可以重传报文，TIME_WAIT 的时间由具体实现有关，典型值：30s、1min、2min。

# 流量控制

一条 TCP 连接的每一侧主机都为该连接设置了接收缓存，流量控制就是防止接收方接收缓存溢出。

流量控制就是一个速度匹配的服务，让发送方的发送速率和接受方应用程序的读取速度相匹配。

TCP **发送方**维护一个称为接收窗口的变量来提供流量控制，该变量指示了接受方还有多少可用的缓存空间。

接收方跟踪以下变量：

- `RcvBuffer`：接收缓存的大小

- `LastByteRead`：应用程序从缓存读出的数据流的最后一个字节的编号
- `LastByteRcvd`：从网络中到达的并且已放入接收缓存中的数据流的最后一个字节编号

并且 `LastByteRcvd - LastByteRead <= RcvBuffer`

接收窗口使用 `rwnd` 表示，并且满足以下关系：

`rwnd = RcvBuffer - (LastByteRcvd - LastRead)`

发送方需要跟踪两个变量：

- `LastByteSent`：最后一个发送的字节编号
- `LastByteAcked`：最后一个确认的字节编号

在整个连接过程当中，只要保证未确认的数据大小在接收窗口大小的范围之内，即：

`LastByteSent - LastByteAcked <= rwnd`

当接收方的 `rwnd` 大小为 0 时，并且接收方没有数据发送给发送方，则发送方会被阻塞而不能发送数据，无法知晓接收方的接收缓存何时有了新的空间。

为了解决该问题，TCP 规范中要求：当接收方的接收窗口为 0 时，发送方继续发送只有一个字节的报文段，这样报文段最终一定会被接收方确认，这样即可解决阻塞问题。

# 拥塞控制

拥塞控制的方法分为两类：

1. 端到端拥塞控制，这类拥塞控制网络层没有为运输层提供显示帮助
2. 网络辅助的拥塞控制，这类拥塞控制路由器会向发送发提供网络中的拥塞状态

TCP 实现拥塞控制的方法：

1. 采用的是端到端拥塞控制，因为 IP 没有显示的提供有关网络拥塞的信息
2. 让每一个发送方根据所感知到的网络拥塞程度来限制其发送速率

丢包一般是由于网络变得拥塞时由于路由器缓存溢出引起，TCP 通过是否出现丢包来感知此时网络是否拥塞，而丢包事件定义为：超时或三个冗余 ACK。

简单来说，TCP 拥塞控制的策略就是：

1. 当遇到报文丢失，则代表网络拥塞，此时降低发送速率
2. 当收到一个正确的确认报文，代表此时网络状态良好，增加发送速率

也就是丢包和 ACK 充当了隐式信号，TCP 根据这两个事件来进行增加速率和降低速率。

TCP 发送方限制发送速率的方式通过跟踪一个额外的变量：拥塞窗口 `cwnd`

在发送方中**未被确认的数据流**不会超过 `cwnd` 和 `rwnd` 的最小值，即：

`LastByteSent - LastByteAcked <= min { cwnd, rwnd }`

TCP 的拥塞控制算法分为三个部分：慢启动、拥塞避免、快速恢复

## 慢启动

`cwnd` 的初始值为 1 MSS，并且每当传输的报文**首次被确认**就增加 1 MSS。

![](http://oss.xiefeng.tech/img/20210802214657.png)

 ssthresh ：慢启动阈值，一个状态变量

当由于一个**超时**指示的丢包事件发生，会将 `ssthresh` 的值设置为 `cwnd / 2`， `cwnd` 置为 1 MSS，重新开始慢启动过程

当检测到 ` cwnd` 的值为 `ssthresh` 时，结束慢启动并进入**拥塞避免**阶段。

如果检测到 3 个冗余 ACK，则执行快速重传并进入**快速恢复**阶段。

## 拥塞避免

进入拥塞避免状态时，`cwnd` 的值大约是上次遇到拥塞时的一半，也就是说距离拥塞并不遥远，此时需要谨慎的增加 `cwnd`。

每个 RTT （一个 RTT 会发送好几个报文）只将 `cwnd` 的值增加 1 MSS，一个通用的方法是此时对于每到达的一个 ACK，将 `cwnd` 增加 $MSS/cwnd * MSS$ 字节。

![](http://oss.xiefeng.tech/img/20210802215101.png)

## 拥塞发生

拥塞避免算法就是将原本慢启动算法的指数增长变成了线性增长，还是增长阶段，但是增长速度缓慢了一些。

就这么一直增长着后，网络就会慢慢进入了拥塞的状况了，于是就会出现丢包现象，这时就需要对丢失 的数据包进行重传。

当出现超时，`ssthresh` 的值更新为 `cwnd` 的一半，将 `cwnd` 设置为 1 MSS，进入慢启动

![](http://oss.xiefeng.tech/img/20210802215744.png)

当出现 3 个冗余 ACK，更新 `cwnd = cwnd/2`，`ssthresh = cwnd` 并进入**快速恢复**阶段

## 快速恢复

快速恢复算法是认为，你还能收到 3 个重复 ACK 说明网络也 不那么糟糕，所以没有必要像超时那么强烈。

进入快速恢复之前， cwnd 和 ssthresh 已被更新了

对于引起 TCP 进入快速恢复阶段的缺失报文，对收到的每个冗余 ACK 让 `cwnd` 增加 1 MSS，也就是 `+3`

- 如果再收到重复的 ACK，那么 cwnd 增加 1
- 当丢失报文段的 ACK 到达时，把 cwnd 设置为的 ssthresh 的值，进入**拥塞避免**阶段
- 出现超时事件，会更新 `ssthresh` 的值，重置 `cwnd` 为 1 MSS，并进入**慢启动**阶段

快速恢复就是快速的恢复之前的状态，再次进入拥塞避免状态

![](http://oss.xiefeng.tech/img/20210802220248.png)

TCP 拥塞控制的特点是：每个 RTT 线性增加 1 MSS，出现冗余 ACK 减半，概括为：**加性增，乘性减**

![](http://oss.xiefeng.tech/img/20210802220348.png)

