# 递归树

递归的思想是将大问题分解为小问题，然后再将小问题分解为小小问题。这样一层一层地分解，直到问题的数据规模被分解得足够小，不用继续递归分解为止。

如果把这个一层一层的分解过程画成图，它其实就是一棵树。给这棵树起一个名字，叫作**递归树**。

以递归求解fib为例：

```javascript
function fib(n) {
    return n <= 2 ? 1 : fib(n -1) + fib(n - 2);
}
```

递归树就长这个样子：

![](http://oss.xiefeng.tech/img/20210406095225.png)

# 时间复杂度

使用递归树分析时间复杂度的思路是：

1. 让递归树中的每个结点表示一个单一子问题的代价
2. 在创建递归树之后，对树的每层的各子问题的代价进行求和，得到每一层的代价
3. 将所有层的代价加起来，得到整棵递归树的总代价，这个总代价就是递归式的解

## fib

可以将该算法的时间复杂度表达式写出来 `T(n) = T(n-1) + T(n - 2)`

每一个节点的代价为 `O(1)`，画出递归树就是这个样子：

![](http://oss.xiefeng.tech/img/20210406102000.png)

所以 `T(n) = 1 + 2 + 4 + .....`，所以使用递归树求解需要直到数的高度。

对于 fib 来说，树的高度介于 $n$ 和 $\frac n 2$ 之间。

当树高为 $n$ 时：$T(n) = 1 + 2 + 4 + ... + 2^{n-1} = 2^n-1$，所以$T(n) = O(2^n-1)$

当树高为 $\frac n 2$ 时：$T(n) = 1 + 2 + 4 + ... + 2^{\frac n 2-1} = 2^{\frac n 2}-1$，所以 $T(n) = O(2^{\frac n 2}-1)$

所以 fib 的时间复杂度介于 $O(2^n-1)$ 和 $O(2^{\frac n 2}-1)$ 之间，但是可以得出该算法的时间复杂度在指数级别 $O(2^n)$

## 其他

只要写出了复杂度的表达式就可以构造递归树将每一层的复杂度相加得到最终结果。

比如 `T(n) = 2 * T(n / 2) + n`

![](http://oss.xiefeng.tech/img/20210406103537.png)

![](http://oss.xiefeng.tech/img/20210406103616.png)

https://www.bilibili.com/video/BV1sE411Z71P?p=1&t=169https://www.bilibili.com/video/BV1sE411Z71P?p=1&t=169

# 空间复杂度

递归的空间复杂度比较好分析，就是递归深度 * 每一个节点所占的空间。