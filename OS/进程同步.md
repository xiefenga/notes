# 进程的协作

协作进程能与系统内的其他执行进程互相影响。协作进程或能通过直接共享逻辑地址空间（代码和数据），或能通过文件或消息来共享数据。共享数据的并发访问可能导致数据的不一致。

进程间的协作关系分为：同步、互斥、通信。

## 同步

进程具有异步的特性，异步特性是指各并发执行的进程以各自独立的、不可预知的速度向前推进。

进程同步是指**多个进程中发生的事件存在某种先后顺序**。即某些进程的执行必须先于另一些进程，其任务是使得并发执行的诸多进程有效的共享资源和相互合作。

## 互斥

各个并发执行的进程不可避免的需要共享一些系统资源，但是某些资源一段时间内只允许一个进程访问该资源。

**临界资源：** 一个时间段内只允许一个进程使用的资源。

进程互斥指当一个进程访问某个临界资源时，另一个想要访问该资源的进程必须等待，只有当前访问临界资源的进程访问结束释放了该资源之后，其他进程才可以去访问。

# 临界区问题

**临界区：**访问临界资源的那段代码。

临界资源的访问：

```
do {
	进入区
	临界区
	退出区
	剩余区
} while(true)
```

进入区：负责检查是否可以进入临界区，如果可以则要设置正在访问临界资源的标志（上锁）

退出区：负责接触正在访问临界资源的标志（解锁）

剩余区：其他操作

**临界区问题：** 设计一个协议完成这些区域的功能，实现在进入临界区之前需要请求许可。

解决临界区问题，并保证系统整体性能，需要遵循的原则：

1. 空闲让进：临界区空闲，可以允许一个请求进入的进程立即进入。
2. 忙则等待：当已有进程进入临界区，则其他需要进入的进程需要等待。
3. 有限等待：对于请求进入的进程，应该在有限时间内进入临界区（保证不会饥饿）
4. 让权等待：当进程不能进入临界区需要等待的时候，立即释放 CPU，防止忙等待。

# 软件方法

## 单标志法

两个进程在访问临界区后会把临界区的权限转交给另一个进程。每一个进程进入临界区的权限只能被另一个进程赋予。

![](https://xf-blog-imgs.oss-cn-hangzhou.aliyuncs.com/img/image-20201221160711171.png)

单标志法可以实现同一时刻最多一个进程在临界区，但是违背了空闲让进。

## 双标志先检查

设置一个布尔数据来标记各进程想进入临界区的意愿，每个进程在进入临界区之前先检查有没有别的进程想进临界区，如果没有则设置自己的意愿，然后开始访问。

![](https://xf-blog-imgs.oss-cn-hangzhou.aliyuncs.com/img/image-20201221161052338.png)

由于进入区的检查和上锁可能会被中断，会出现两个进程都进入临界区的情况。

## 双标志后检查

根据双标志先检查改版，先上锁再检查。

![](https://xf-blog-imgs.oss-cn-hangzhou.aliyuncs.com/img/image-20201221161543737.png)

由于进入区的检查和上锁可能会被中断，会出现两个进程都上锁但是通不过检擦的情况，发送了死锁。

## Peterson 算法

双标志后检查中两个进程都抢着进入临界区，会产生死锁的情况，可以尝试”孔融让梨“，主动让对方先进。

<img src="https://xf-blog-imgs.oss-cn-hangzhou.aliyuncs.com/img/image-20201221162034398.png" style="zoom:80%;" />

Peterson 算法解决了临界区的问题，但是没有符合让权等待原则。

# 硬件方法

通过提供硬件指令**原子**的执行（类似于原语无法被中断，但是原因是因为这是**一条**硬件指令）来决临界区问题。

## TS 指令

test_and_set 执行，简称 TS 指令 / TSL 指令

用 C 语言描述其逻辑：

```c
bool test_and_set(bool *lock) {
    bool old = *lock;
    *lock = true;
    return old;
}
```

使用 TS 指令：

```c
bool lock = false;	// 共享变量，用于表示临界区是否加锁
while(test_and_set(&lock)); // 进入区 检查并上锁
 // 临界区
lock = false; // 退出区 解锁
// 剩余区
```

相遇软件的实现，TSL 指令将上锁和检查的操作用硬件实现的方式变成了一个一气呵成的原子操作。

优点：实现简单，无需软件实现方式的严格检查是否有逻辑漏洞，适用于多核 CPU 环境

缺点：依旧不满足让权等待原则，无法进入临界区的进程依旧会忙等待

## Swap 指令

类似于 TSL 指令，也可以称为 Exchange 指令，XCHG 指令

用 C 语言描述其逻辑：

```c
void Swap(bool *a, bool *b) {
    bool temp = *a;
    *a = *b;
    *b = temp;
}
```

使用 Swap 指令：

```c
bool old = true;
while(old == true) {
    Swap(&lock, &old);
}
// 临界区
lock = false; // 退出区 解锁
// 剩余区
```

和 TSL 指令的区别不大，本质上没什么区别，优缺点相同。

# 信号量

信号量就是一个变量（可以是一个整数也可以是一个记录型变量）用来表示系统中某种资源的数量，比如系统只有一台打印机，就可以设置一个初始值为1的信号量。

用户进程可以使用操作系统提供的一对原语操作信号量来很方便的解决临界区问题，解决进程同步和互斥。

一对原语：`wait(S)` 和 `signal(S)`，参数 S 为信号量，相当于进入区和退出区。

这两个原语简称 P、V 操作，P(S)、V(S)，来源荷兰语（proberen 测试，verhogen 增加）

## 整型信号量实现

信号量用一个整型变量表示

`wait` 的定义方式：

```c
void wait(int S) {
    while(S < = 0);	// 如果资源数不够一直循环等待
    S = S - 1;	// 资源数够则占用一个
}
```

`signal` 的定义方式：

```c
void signal(int S) {
    S = S + 1; // 使用完资源后，释放资源
}
```

缺点：不满足让权等待，会发生忙等待

## 记录行信号量实现

定义信号量：

```c
typedef struct {
    int value; //剩余资源数，为负数代表等待该资源的数量
    struct process *L; // 该资源的等待队列
} semaphore;
```

`wait` 的定义方式：

```c
void wait(semaphore S) {
    S.value --;
    if (S.value < 0) {
        block(S.L);	// 主动将该进程变为阻塞态，并挂到该信号量的等待队列中
    }
}
```

`signal` 的定义方式：

```c
void signal(semaphore S) {
    S.value ++;
    if (S.value <= 0) {
        wakeup(S.L); // 主动唤醒等待队列上的一个进程
    }
}
```

**阻塞和唤醒操作都是原语**

## 实现进程互斥

1. 设置互斥信号量 ，初值为 1
2. 在临界区之前执行 P 操作
3. 在临界区之后执行 V 操作
4. 对不同的临界资源需要设置不同的互斥信号量

```c
semaphore mutex = 1; // 简写 初始化信号量

// process 1:
P(mutex);
// 临界区
V(mutex);
// ...

// process 2:
P(mutex);
// 临界区
V(mutex);
//...
```

## 实现进程同步

1. 设置同步信号量，初始为 0
2. 在先执行操作的进程中执行 V 操作
3. 在后执行操作的进程中执行 P 操作

```c
semaphore mutex = 0; // 简写 初始化信号量

// process 1:
V(mutex);
// ...

// process 2:
P(mutex);
//...
```

# 生产者—消费者问题

系统中有一组生产者进程，一组消费者进程，生产者每次生产一个数据放入缓冲区，消费者每次从缓冲区取出一个数据。

缓冲区没满，生产者才可以放入数据，缓冲区满了消费者才可以取数据，缓冲区是临界资源，各进程需要互斥的访问。

信号量定义：

```c
semaphore mutex = 1;  // 互斥信号量，用户互斥的访问缓冲区
semaphore empty = n;  // 同步信号量，表示空闲缓冲区的数量
semaphore full = 0;  // 同步信号量，表示非空缓冲区的数量
```

生产者进程：

```c
while(1) {
    P(empty); // 看看 缓冲区是否有空闲
    P(mutext);
    // 临界区
    V(mutex);
    V(full); // 增加产品
}
```

消费者进程：

```c
while(1) {
    P(full); // 看看缓冲区是否满了
    P(mutex);
    // 临界区
    V(mutex);
    V(empty); // 增加空闲
}
```

结论：

1. 实现互斥的 P 操作一定要放在实现同步的 P 操作之后，否则可能产生死锁
2. V 操作不会导致死锁，互斥和同步的 V 操作可以互换位置

# 读者—写者问题

有读者和写者两组并发进程共享一个文件，则需要保证：

1. 多个读进程允许共同执行读操作
2. 只允许一个写进程进行写操作
3. 任一写进程在完成写操作之前其他进程无法访问该文件
4. 写进程执行写操作之前其他进程都已经退出

**方式一**

信号量：

```c
semaphore rw = 1;  // 用于实现对文件的互斥访问（读进程和写进程之间，写进程和写进程之间）
int count = 0;   // 记录多少读进程正在读取该文件
semaphore mutex = 1; // 用于对 count 的互斥操作
```

写进程：

```c
while(1) {
    P(rw); // 加锁
    // 临界区
    V(rw); // 解锁
}
```

读进程：

```c
while(1) {
    P(mutex); // 各读进程互斥的访问 count,防止中count还没++导致多次给 rw 加锁 
    if (count == 0) {
        P(rw); // 第一个读进程加锁
    }
    count ++;
    V(mutex);
    // 临界区
    P(mutex);
    count --;
    if (count == 0) {
        V(rw); // 最后一个读进程解锁
    }
    V(mutext);
}
```

缺点：读进程的优先级比较高，只要有读进程，写进程则会一直等待

**方式二**

```c
semaphore rw = 1;  // 用于实现对文件的互斥访问（读进程和写进程之间，写进程和写进程之间）
int count = 0;   // 记录多少读进程正在读取该文件
semaphore mutex = 1; // 用于对 count 
semaphore w = 1; // 用于实现 “写优先” / 读写公平
```

写进程：

```c
while(1) {
    P(w);
    P(rw); // 加锁
    // 临界区
    V(rw); // 解锁
    V(w);
}
```

读进程：

```c
while(1) {
    P(W);
    P(mutex); // 各读进程互斥的访问 count,防止中count还没++导致多次给 rw 加锁 
    if (count == 0) {
        P(rw); // 第一个读进程加锁
    }
    count ++;
    V(mutex);
    V(w);
    // 临界区
    P(mutex);
    count --;
    if (count == 0) {
        V(rw); // 最后一个读进程解锁
    }
    V(mutext);
}
```

# 哲学家进餐问题

> 假设有五位哲学家围坐在一张圆形餐桌旁，做以下两件事情之一：吃饭，或者思考。吃东西的时候，他们就停止思考，思考的时候也停止吃东西。餐桌中间有一大碗意大利面，每位哲学家之间各有一只餐叉。因为用一只餐叉很难吃到意大利面，所以假设哲学家必须用两只餐叉吃东西。他们只能使用自己左右手边的那两只餐叉。哲学家就餐问题有时也用米饭和五根筷子而不是意大利面和餐叉来描述，因为吃米饭必须用两根筷子。

避免死锁的方式：

1. 最多只允许四个哲学家同时用餐
2. 奇数编号的哲学家先拿起左手边的餐具，偶数编号哲学家先拿起右手边的餐具
3. 各哲学家拿餐具时互斥

```c
semaphore chopstick[5] = {1,1,1,1,1}; // 餐具
semaphore mutex = 1; // 互斥的拿餐具

// 哲学家进程
while(1) {
    P(mutex);
    P(chopstick[i]); // 拿左手边餐具
    P(chopstick[(i + 1) % 5]); // 拿右手边餐具
    V(mutex);
    // 吃饭
    V(chopstick[i]); // 左手边餐具解锁
    V(chopstick[(i + 1) % 5]); // 右手边餐具解锁
}
```

# 管程

信号量机制的问题：编写程序困难，容易出错。

管程：是一种抽象数据类型，和类的定义类似，可以让程序员不再关注 P V 操作，1973年，Pascal 语言首次引入这种高级同步机制。

**管程的组成：**

1. 共享数据局部属于管程
2. 管程具有方法来操作共享数据
3. 共享数据具有初始化语句
4. 管程具有名字

**管程的特征：**

1. 局部于管程的数据只有管程内的方法能访问
2. 一个进程只能通过调用管程的方法来实现共享数据的操作（每次只有一个进程在管程内处于活动状态）
3. 每次只有一个进程能访问方法
4. 管程方法的互斥访问由编译器实现
5. 我们可在管程内设置条件变量来以及等待和唤醒来解决同步问题

Java 中的 `synchronized` 挂机案子提供了类似于管程的机制。

# 死锁

死锁：每一个进程都在等待被另一个进程占有的、不能抢占的资源。

死锁产生的必要条件：

- 互斥
- 占有并等待
- 非抢占
- 循环等待

**对不可剥夺资源的不合理分配就会导致死锁。**

死锁的处理：

- 死锁预防
- 避免死锁
- 死锁的检测和恢复 

## 死锁预防

### 破坏互斥

因为只有对必须互斥使用的资源发生争抢才会造成死锁，把互斥的资源改造为共享的资源。

例如：SPOOLing 技术，把独占设备在逻辑上改造为共享设备，用该技术将打印机资源改为共享设备

![](https://xf-blog-imgs.oss-cn-hangzhou.aliyuncs.com/img/image-20201222170055871.png)

**缺点：** 并不是所有的资源都可以改造成共享资源，有的时候就是需要互斥资源为了系统的安全。

### 破坏非抢占

方案一：当一个进程请求的资源得不到满足时，它必须立即释放保持的所有资源，后续再申请。

方案二：当某个进程请求的资源被占有时，可由操作系统协助将该资源强行剥夺。

**缺点：**

1. 实现复杂
2. 会导致进程之前的工作失效
3. 会增加系统开销，降低系统吞吐量
4. 可能会导致进程饥饿

### 破坏占有并等待

让进程在运行前一次将所需要的资源都申请，当不满足的时候则该进程不能运行。

**缺点：**

1. 由于某些资源只需要使用很短的时间会造成资源浪费，资源利用率低
2. 也可能导致进程饥饿

### 破坏循环等待

可采用顺序资源分配法，首先给系统中的资源分配编号，规定每个进程必须按编号递增的顺序请求资源，同类资源一次性申请完。

缺点：

1. 不方便系统增加新的资源
2. 进程实际使用资源的顺序可能不一致，会导致资源浪费
3. 编程麻烦

## 死锁避免

### 银行家算法

借钱给有能力偿还的客户，系统首先检查申请者对资源的最大需求量，如果现存的资源可以满足它的最大需求量时，就满足当前的申请。

核心思想：在进程提出申请时，先预判此次分配是否会导致系统进入不安全状态，如果会则先阻塞该进程。

**安全序列：**系统按照这种序列分配资源，则每个进程都能顺利执行完成。

**安全状态：** 只要系统能找出一个安全序列，则系统处于安全状态。

系统处于安全状态一定不会发生死锁，发生死锁一定处于不安全状态，处于不安全状态未必发生了死锁。

**安全算法：** 用于判断系统是否处于安全状态

**安全算法步骤:**

1. 检查当前的剩余可用资源是否能满足某个进程的最大需求
2. 如果可以，就把该进程加入安全序列，并把该进程持有的资源全部回收
3. 不断重复上述过程，看最终是否能让所有进程都加入安全序列

实现该算法需要的**数据结构**：

- Available：长度为 m 的向量，表示系统中 m 种资源每种资源的可用实例数量，`available[i] = k` 代表资源类型 i 有 k 个可用
- Max： n * m 矩阵，定义每个进程的最大需求，`max[i][j]= k` 代表进程 i 最多会申请 j 类型资源 k 个
- Allocation： n * m 矩阵，定义每个进程现在已经分配的每种资源类型数量
- Need： n * m 矩阵，表示每个进程还需要的资源

**银行家算法步骤：**

1. 检查此次申请是否超过了之前声明的最大需求数
2. 检查此时系统剩余的可用资源是否还能满足这次请求
3. 试探着分配，更改各数据结构
4. 用安全性算法检查此次分配是否会导致系统进入不安全状态

## 死锁的检测和恢复

### 死锁的检测

设置两张**表格（矩阵）**来记录进程使用资源的情况：

- 等待资源表记录每个被阻塞进程等待的资源
- 占用资源表记录每个进程占有的资源

**算法：**

进程申请资源时，先查该资源是否为其它进程所占用；若资源空闲，则把该资源分配给申请者且登入占用资源表；否则，则登入进程等待资源表。死锁检测程序定时检测这两张表，如果系统中存在一组循环等待资源的进程则产生了死锁。

使用**资源分配图**来记录资源的请求和分配情况：

<img src="https://xf-blog-imgs.oss-cn-hangzhou.aliyuncs.com/img/%E8%B5%84%E6%BA%90%E5%88%86%E9%85%8D%E5%9B%BE.svg" style="zoom: 67%;" />

**算法：**

从资源分配图钟，删除所有资源类型节点，合并适当边就可以得到等待图，如果等待图中存在还，则系统会发生死锁。

### 死锁的恢复

- 资源剥夺
- 进程终止
	- 终止全部死锁进程
	- 一个一个终止，知道死锁解除
- 进程回退