# 基本硬件

> 内存是现代计算机运行的核心，内存由一个很大的字节数组组成，每个字节都有各自的地址。

机器指令可以用内存地址作为参数，但是无法使用磁盘地址作为参数，所以需要执行的指令和需要使用的数据必须存在内存中，如果数据不在内存中则必须先移动到内存中再运行。

## 速度

CPU 可以在一个时钟周期内完成对 CPU 内置寄存器的访问，但是对于内存的访问可能需要多个 CPU 时钟周期。

> 时钟周期：一般也称振荡周期，即 CPU 的晶振的工作频率的倒数，是计算机中最基本的、最小的时间单位。
>
> CPU 周期：又称机器周期，定义为从内存读取一条指令字的最短时间。一个指令周期常由若干 CPU 周期构成。
>
> 指令周期：指令周期是执行一条指令所需要的时间，即 CPU 从内存取出一条指令并执行这条指令的时间总和。

因为 CPU 对内存的访问时频繁的，为了 CPU 在执行指令的过程中不会因为等待内存返回数据而进行等待，就需要在 CPU 和内存之间加上 cache，提高速度。

## 保护

我们需要确保操作系统的正确性，需要保护操作系统不被应用进程篡改，以及进程和进程之间也不能互相影响。

通过两个寄存器：**基地址寄存器**和**界限地址寄存器**，来实现进程只能访问合法地址。

**基地址寄存器**指示了该进程的最小合法物理内存地址；**界限地址寄存器**指示了合法内存的大小。

当一个进程试图访问不合法的地址会陷入操作系统，只有操作系统通过特权指令才能修改基地址寄存器和界限地址寄存器的值。

# 地址空间

**逻辑地址：**CPU 生成的地址，也叫做相对地址，地址都是从 0 开始（相对于进程的起始地址），也可以称为虚拟地址。

**物理地址：**访问内存单元的地址，也叫绝对地址，加载到 MDR 中的值就是物理地址。

从逻辑地址到物理地址的映射时由内存管理单元（MMU）的硬件完成，为了完成这种映射需要使用到**基地址寄存器**，在这里也叫**重定位寄存器**。

![](https://xf-blog-imgs.oss-cn-hangzhou.aliyuncs.com/img/%E5%9C%B0%E5%9D%80%E8%BD%AC%E6%8D%A2.svg)

**地址绑定**

源代码中的地址都是用符号表示（相对地址），但是在内存中执行时使用的都是内存的物理地址，需要实现地址的绑定：

- 编译时：绝对绑定，在编译时生成绝对地址代码，该方式只适合单道程序环境
- 加载时：静态重定位，在进程加载到内存时，地址实现绑定，该方式需要一次性给进程分配所有需要的内存并且运行期间不能移动
- 运行时：动态重定位，在运行时地址才实现绑定，这意味着进程在执行时可以从一个内存段移动到另一个内存段

大多数的通用计算机系统使用的都是运行时地址绑定，但是这种方案需要特定的硬件。

**程序从源代码到运行的过程：**

1. 编译：由编译程序将源代码编译成若干目标模块（高级 ---> 机器）
2. 链接：由链接程序将多个目标模块以及所需的库函数链接在一起形成一个完整的装入模块
3. 装入：由装入程序将完整的装入模块装入内存运行

**链接的三种方式：**

1. 静态链接
2. 装入时动态链接
3. 运行时动态链接

# 交换

> 进程必须在内存中才能执行，不过进程可以暂时从内存**交换**到备份存储中，当再次执行时再调回内存。交换可以让所有进程的总的物理地址空间超过实际的物理地址空间，增加系统的多道程序程度。

**标准交换**

系统维护一个可运行的所有进程的就绪队列，他们的映像在备份存储中（PCB会常驻内存），当 CPU 调度器决定要执行一个进程时，会先检查下一个进程是否在内存中。如果不在并且没有空闲内存区域，就会换出内存中的一个进程然后换入需要的进程。

换出的进程的状态为**挂起状态**。

标准交换的效率比较低，因为备份存储是硬盘传输时间和交换的内存大小成正比，这样上下文的切换时间相当高。现代操作系统并不使用标准交换，而是使用一种变种：正常情况下，禁止交换；当空闲内存低于某个阈值，启用交换。

通常这些交换的变种和虚拟内存一起工作。

**移动系统**

移动系统 iOS 和 Android 不支持交换，因为存储介质使用的是闪存而不是磁盘。

当空闲内存下降到一定阈值时，iOS 要求应用程序自愿放弃内存；Android 会终止进程。

# 内存分配

## 连续分配

内存分为两个区域：操作系统和用户进程。一般操作系统放在低内存（由中断向量决定）

连续内存分配会使每个进程位于一个连续的内存区域，和下一个进程内存相连。

**内部碎片：** 分配给进程的内存区域中有部分没有用上。

**外部碎片：** 内存中空闲的分区由于太小难以利用

解决外部碎片的方法：

- 一种解决办法事是**紧缩**，目的是移动内存内容将所有空闲空间合并成一整块，但是并非是总可能的，比如重定位是静态的。

- 另一种解决办法是允许进程的逻辑地址空间不连续，比如分段合分页。

### 固定分区分配

最简单的内存分配方法就是将内存分为多个固定大小的分区，每个分区只可以放置一个进程。

因此多道程序的程度受限于分区数，当一个分区空闲时可以从磁盘调入一个进程，当一个进程终止时该分区可以用于其他的进程。

操作系统需要建立一个分区说明表的数据结构来记录分区的分配情况，每个表现包括对应分区的大小、起始地址、分配情况。

优点：

- 实现简单
- 无外部碎片

缺点：

- 当用户程序太大时无法满足要求
- 会产生内部碎片
- 存储器利用率低

### 可变分区分配

这种分配方式不会预先划分内存分区，而是在进程装入内存时，根据进程的大小动态地建立分区。

操作系统使用空闲分区表来记录空闲的分区。开始时所有内存都可用于用户进程，可用内存称之为**孔**，表中记录的就是孔的集合。

随着进程的进入和出去，可用的内存块为分散在内存里不同大小的孔的集合。

新孔会和相邻的孔合成大孔，分配内存时大孔可以分成两个孔一个分配给进程一个还回集合。

优点：无内部碎片

缺点：有内部碎片，需要实现动态分区分配算法

**动态分区分配算法**

从一组空闲分区（孔）选择一个空闲分区（孔）的常用算法：

- 首次适应
- 最优适应
- 最差适应
- 邻近适应

**首次适应：** 空闲分区以地址递增的方式排列，每次寻找分区都是从头开始寻找，知道找到第一个能满足要求的分区就行。

**最优适应：** 空闲分区按容量递增次序排列，每次寻找到最小能满足要求的分区（第一个能满足要求的）。

**最坏适应：** 空闲分区按容量递减次序排列，每次寻找到最大能满足要求的分区（第一个）。

**邻近适应：** 空闲分区以地址递增的方式排列，每次都从上次查找结束的位置接着查找，直到找到满足要求的分区。

最优适应算法容易产生许多难以利用的外部碎片，最坏适应算法容易将大分区用完，对大进程不友好。这两个算法是每次分配完都需要重新排序有额外的开销。邻近适应算法也容易将高地址部分的大分区用完。**首次适应算法反而效果更好。**

## 非连续分配（离散）

### 分页

将**物理内存**分为固定大小的块，称之为帧/页帧（frame），用户进程的地址空间也分为同样大小的块，称之为页/页面（page），给每一页、帧进行编号，从 0 开始。

操作系统以页为单位为各个进程分配内存空间（将进程以页为单位进行划分）。进程的页面和内存的页帧有一一对应的关系，各个页面不必连续存放。

#### 地址转换

CPU 生成的地址组成：<页号, 页偏移>

物理地址 = 页面的起始物理地址（内存块号 * 页面大小） + 页偏移

页（帧）的大小由硬件决定，大小为 2 的幂。将页的大小选为 2 的幂可以很快的将逻辑地址转换为页码和页偏移。

十进制表示：

- 页号：逻辑地址 / 页面大小

- 页偏移：逻辑地址 % 页面大小

二进制表示：

逻辑地址空间为 $2^m$B，页大小为 $2^n$B

- 页号：前 m - n 位
- 页偏移：后 n 位

假设用 32 位表示逻辑地址，页面大小为 4 KB = $2^{12}$B

0 号页的逻辑地址空间为：0 - 1023：

```c
000000000000 000000000000 - 000000000000 111111111111
```

1 号页的逻辑地址空间为：1024 - 2047：

```c
000000000001 000000000000 - 000000000001 111111111111
```

在分页存储管理中，只要确定了页面大小，逻辑地址结构就能确定。只要给出逻辑地址，就能得出页号，偏移，进而得出物理地址，所以**页式管理中地址是一维的。**

#### 页表

为了能够知道进程的每个页面在内存中的存放位置，操作系统要为每个进程都建立一张页表。

- 一个进程对应一个一张页表
- 进程的每一页对应一个页表项
- 每个页表项由页号和块号（帧号）组成
- 每个页表项记录和进程页面和实际内存块（帧）之间的对应关系
- 每个页表项的长度是相同的，页号是**隐含**的

![](https://xf-blog-imgs.oss-cn-hangzhou.aliyuncs.com/img/%E9%A1%B5%E8%A1%A8.svg)

**为什么页表项的长度相同，页号隐含：**

各页表项会按顺序连续的存在内存中，如果该页表在内存中存放的起始地址为 X，则 M 页对应的页表项的地址为 X + M * 页表项长度

因此只需要知道页表存放的起始地址和页表项长度即可获取每一页的页表项。

**假设某系统物理内存大小为4GB，页面大小为4KB，则每个页表项至少应该为多少字节?**

4 GB = $2^{32}$B ，4 KB = $2^{12}$B，页表项数目（帧数目，内存块数目）为 $2^{32} / 2^{12} = 2^{20}$，内存块的编号为：0 - $2^{20}-1$

所以需要 20 位来表示这么多表项，至少需要 3B 来表示每个表项。

**帧表**

操作系统管理物理内存，需要知道内存分配的细节：内些帧已分配，哪些帧空闲。这些信息可以通过**帧表**实现。

#### 硬件转换地址

基本地址变换机构可以借助进程的页表将逻辑地址转换为物理地址。

通常会在系统中设置一个**页表寄存器**，存放页表在内存中的**起始地址**和**页表长度**。

进程未执行时，这些信息保存在 PCB 中，进程被调度时，这些信息会被写入页表寄存器中。

![](https://xf-blog-imgs.oss-cn-hangzhou.aliyuncs.com/img/image-20201224164731779.png)

#### 快表（TLB）

程序具有**局部性原理**：

- 时间局部性：某条指令在执行了之后不久之后可能会再次被执行；某个数据在访问了之后不久之后可能会被再次访问
- 空间局部性：某个内存单元被访问了之后，不久之后附近的存储单元也有可能被访问

在程序执行过程中，每次访问一个逻辑地址都需要进行两次内存访问（一次是页表条目，一次是最终物理地址），由于局部性原理，可能连续很多次查到的都是同一个页表项（同一页）。

快表，又称联想寄存器（TLB)，是一种访问速度比内存快很多的高速缓冲存储器，用来存放当前访问的若干页表项，以加速地址变换的过程。类似于 cache 来加速内存的访问，是内存的高速 缓存。

TLB与页表一起按如下方式使用：当CPU产生逻辑地址后，其页号提交给TLB。如果页码不在TLB中（称为**TLB失效**），那么就需要访问页表并将页号和帧号增加到TLB中。如果TLB中的条目已满，那么操作系统会选择一个来替换。另外，有的TLB允许有些条目固定下来，通常内核代码的条目是固定下来的。

![](https://xf-blog-imgs.oss-cn-hangzhou.aliyuncs.com/img/image-20201224170016001.png)

#### 多级页表

单级页表存在的问题：

1. 页表必须连续存放，因此当页表很大时，需要占用很多个连续的内存块
2. 没有必要让整个页表常驻内存，因为进程在一段时间内可能只需要访问某几个特定的页面

可将长长的页表进行分组，使每个内存块刚好可以放入一个分组（比如页面大小4KB，每个页表项4B，每个页面可存放1K个页表项，因此每1K个连续的页表项为一组，每组刚好占一个内存块，再将各组离散地放到各个内存块中)

另外，要为离散分配的页表再建立一张页表，称为**页目录表**，或称外层页表，或称顶层页表。

![](https://xf-blog-imgs.oss-cn-hangzhou.aliyuncs.com/img/image-20201224172614829.png)

### 分段

**进程的地址空间：** 按照程序自身的逻辑关系划分为若干个段，每个段都有一个段名(在低级语言中，程序员使用段名来编程)），每段从0开始编址。编译程序会将段名转换为段号。

**内存分配规则：** 以段为单位进行分配，每个段在内存中占据连续空间，但各段之间可以不相邻。

**逻辑地址组成：** <段号, 段偏移(段内地址)>

段号的位数决定了每个进程最多可以分几个段；段内地址位数决定了每个段的最大长度是多少。

![](https://xf-blog-imgs.oss-cn-hangzhou.aliyuncs.com/img/image-20201224173742218.png)

#### 段表

- 操作系统为每个进程建立一个段表
- 段表的每个段表项记录了该段在内存中的起始地址
- 段表的每个段表项长度相同，段号可以隐藏

![](https://xf-blog-imgs.oss-cn-hangzhou.aliyuncs.com/img/image-20201224174038970.png)

#### 地址转换

经过编译程序编译之后，形成的等价机器指令：取出段号为x，段内地址为 y的数据。

分段的地址空间是二维地，标识地址时需要段号和段偏移。

![](https://xf-blog-imgs.oss-cn-hangzhou.aliyuncs.com/img/image-20201224174319982.png)

#### 分段和分页的对比

- 分段比分页更容易实现信息的共享和保护
- 页是信息的物理单位，段是信息的逻辑单位；分页对用户不可见，分段对用户可见
- 分页的地址是一维，分段的地址是二维

### 段页式

分页、分段的优缺点：

|      | 优点                                         | 缺点                                                         |
| ---- | -------------------------------------------- | ------------------------------------------------------------ |
| 分页 | 空间利用率高，没有外部碎片，只有少量内部碎片 | 不方便按照逻辑模块实现信息共享和保护                         |
| 分段 | 很方便的按照逻辑模块实现信息的共享和保护     | 如果段长过大，为其分配很大的连续空间会很不方便；会产生外部碎片 |

段页式 = 分段 + 分页

内存按分页方式中分为大小相同的帧，将进程按逻辑模块分段，再将各段分页，再将进程每段的各页分别装入各内存块中

![](https://xf-blog-imgs.oss-cn-hangzhou.aliyuncs.com/img/image-20201225205443354.png)

#### 逻辑地址结构

段页式逻辑地址组成：<段号, 页号, 偏移>

分段是对用户可见的，程序员需要显示的给出段号和段内地址，各段的分页是操作系统完成的，对用户不可见。段页式的地址是二维的。

#### 段表和页表

每个段对应一个段表项，每个段表项由段号、页表长度、页表存放块号组成。每个段表项长度相等，段号隐藏。

每个页面对应一个页表项，每个页表项由页号、页面存放块号组成。每个页表项长度相等，页号隐藏。

![](https://xf-blog-imgs.oss-cn-hangzhou.aliyuncs.com/img/image-20201225210510654.png)

#### 地址转换过程

![](https://xf-blog-imgs.oss-cn-hangzhou.aliyuncs.com/img/image-20201225210716722.png)



# 虚拟内存

传统内存管理的缺点：

1. 一次性：作业必须一次性全部装入内存中才能开始运行
2. 驻留性：一旦作业被装入内存，就会一直驻留在内存中

**虚拟内存：** 根据程序的局部性原理，可以将程序很快用到的数据先装入内存，在执行过程中访问到不在内存中的数据再从磁盘中调入，如果内存不足则将内存中暂时不用的数据调出内存。这就给用户一个比实际物理内存大得多的内存。

**虚拟内存的最大容量 = CPU 寻址范围**

**虚拟内存的实际容量 = min(内存 + 外存, CPU 寻址范围)**

虚拟内存的特征：

1. 无需在进程运行时一次性装入内存，而是可以多次调入内存
2. 进程在运行过程中，作业可以换入换出
3. 从逻辑上扩充了内存的容量

虚拟的内存实现需要建立在离散分配的内存管理方式上。

## 请求分页

请求分页和基本分页的区别：

1. 在程序的执行过程中，当所访问的信息不在内存中时，操作系统负责将所需的内容调入内存
2. 如果内存空间不够，操作系统则会将内存中暂时用不到的信息换出内存

### 页表

1. 和基本分页相比，请求分页管理中，操作系统需要知道进程每一页是否调入内存，该页面存在外存的位置。
2. 当内存空间不够时，操作系统需要通过某些指标来决定到底换出哪个页面，有的页面没有被修改过，就不用再浪费时间写回外存。有的页面修改过，就需要将外存中的旧数据覆盖，因此，操作系统也需要记录各个页面是否被修改的信息。

![](https://xf-blog-imgs.oss-cn-hangzhou.aliyuncs.com/img/image-20201225213544493.png)

### 缺页中断

在请求分页系统中，每当要访问的页面不在内存时，便产生一个缺页中断，然后由操作系统的缺页中断处理程序处理中断。

此时缺页的进程阻塞，放入阻塞队列，调页完成后再将其唤醒，放回就绪队列。

如果内存中有空闲块，则为进程分配一个空闲块，将所缺页面装入该块，并修改页表中相应的页表项。

如果内存中没有空闲块，则由页面置换算法选择一个页面淘汰，若该页面在内存期间被修改过，则要将其写回外存。未修改过的页面不用写回外存。

### 地址转换

![](https://xf-blog-imgs.oss-cn-hangzhou.aliyuncs.com/img/image-20201225213842872.png)

## 页面置换算法

衡量页面置换算法好坏的标准：缺页率。

### 最佳置换算法（POT）

每次选择淘汰的页面将是以后永不使用，或者在最长时间内不被访问的页面。

最佳置换算法可以保证最低的缺页率，但实际上，只有在进程执行的过程中才能知道接下来会访问到的是哪个页面。操作系统无法提前预判页面访问序列。因此，最佳置换算法是**无法实现**的。

### 先进先出置换算法（FIFO）

每次选择淘汰的页面是最早进入内存的页面。

实现方法：把调入内存的页面根据先后顺序排成一个队列，需要换出的页面则在队列头。

FIFO 算法会产生 Belady 异常，另外，FIFO算法虽然实现简单，但是该算法与进程实际运行时的规律不适应，因为先进入的页面也有可能最经常被访问。因此，算法性能差。

**Belady 异常：** 当为进程分配的物理块数增大时，缺页次数不减反增的异常现象。

### 最近最久未使用置换算法（LRU）

每次淘汰的页面是最近最久未使用的页面。

实现方法：赋予每个页面对应的页表项中，用访问字段记录该页面自上次被访问以来所经历的时间 t，每次淘汰 t 最大的页面。

该算法的实现需要专门的硬件，性能好但是实现困难，开销大。

### 时钟置换算法（CLOCK）/ 最近未用算法（NRU）

#### 简单实现

为每个页面设置一个访问位，再将内存中的页面都通过链接指针链接成一个循环队列。当某页被访问时，其访问位置为1。当需要淘汰一个页面时，只需检查页的访问位。如果是0，就选择该页换出；如果是1则将它置为0，暂不换出，继续检查下一个页面，若第一轮扫描中所有页面都是1，则将这些页面的访问位依次置为0后，再进行第二轮扫描（第二轮扫描中一定会有访问位为0的页面，因此简单的CLOCK算法选择一个淘汰页面最多会经过两轮扫描)

#### 改进

简单的时钟置换算法仅考虑到一个页面最近是否被访问过。事实上，如果被淘汰的页面没有被修改过，就不需要执行I/O操作写回外存。只有被淘汰的页面被修改过时，才需要写回外存。

因此，除了考虑一个页面最近有没有被访问过之外，操作系统还应考虑页面有没有被修改过。在其他条件都相同时，应优先淘汰没有修改过的页面，避免I/O操作。这就是改进型的时钟置换算法的思想。修改位为0，表示页面没有被修改过；修改位为1，表示页面被修改过。

用（访问位，修改位）来表示页面的状态。

算法规则：将所有可能被置换的页面排成一个循环队列，

第一轮：从当前位置开始扫描到第一个（0，0）的帧用于替换。本轮扫描不修改任何标志位

第二轮：若第一轮扫描失败，则重新扫描，查找第一个（0，1）的帧用于替换。本轮将所有扫描过的帧**访问位**设为0

第三轮：若第二轮扫描失败，则重新扫描，查找第一个 (0，0）的帧用于替换。本轮扫描不修改任何标志位

第四轮：若第三轮扫描失败，则重新扫描，查找第一个（0，1）的帧用于替换。

由于第二轮已将所有帧的访问位设为0，因此经过第三轮、第四轮扫描一定会有一个帧被选中，因此改进型CLOCK置换算法选择一个淘汰页面最多会进行四轮扫描。

## 页面分配策略

驻留集：请求分页管理中给进程分配的物理块的集合。

**内存块的分配**

固定分配：操作系统给每个进程分配固定数量的内存块，即驻留集的大小不可变。

动态分配：先为进程分配一定的内存块，在程序运行的过程中会动态的增加减少，即驻留集的大小可变。

**置换方式**

局部置换：发生缺页时只能选择进程被分配的内存块进行置换。

全局置换：可以将操作系统保留的空闲物理块分配给缺页进程，也可以将别的进程持有的物理块置换到外存，再分配给缺页进程。

**页面分配置换策略**

1. 固定分配局部置换
2. 可变分配全局置换
3. 可变分配局部置换

可变分配全局置换：只要缺页就给分配新物理块。

可变分配局部置换：要根据发生缺页的频率来动态地增加或减少进程的物理块。

### 页面的调入

**调入时间**

1. 首次调入：一次调入若干相邻的页面，调入的部分由程序员指定
2. 运行时调入：发生缺页时调入缺少的页面

**调入页面的存放位置**
![](https://xf-blog-imgs.oss-cn-hangzhou.aliyuncs.com/img/image-20201225220815823.png)

### 抖动

刚刚换出的页面马上又要换入内存，刚刚换入的页面马上又要换出外存，这种频繁的页面调度行为称为抖动，或颠簸。产生抖动的主要原因是进程频繁访问的页面数目高于可用的物理块数（分配给进程的物理块不够)

**工作集：** 在某段时间内，进程实际访问页面的集合。

操作系统会根据窗口尺寸来计算工作集。

驻留集的大小不能小于工作集，不然会发生频发的缺页。

