## 进程

随着计算机的发展，一台计算机要能干多种事（**多道程序**），作业之间的**切换和调度**成为核心：因为既有**IO**任务， 又有计算任务

我们需要尽可能的让 CPU 忙碌，最大化 CPU 利用率，不能让 CPU 因为 IO 这些任务而被阻塞住

为了提高 CPU 的利用率，操作系统需要能够让 CPU 交替的执行多道程序（并发），CPU 上电后会自动取指执行，管理 CPU 最直接就是修改 PC，但切换运行中的程序不仅仅涉及到修改 PC，还需要保存其他的环境信息进行切换

所以我们发现**运行中的程序和静态程序不一样了**，就引出了一个概念用于表示**运行中的程序**，那就是进程：程序 **+** 那些不一样

进程是对**正在运行的程序**的一个抽象，进程不只是程序的代码段，还包括其他的内容，如 PC、进程堆栈和数据段等

- 程序是被动的实体：本质上就是存储在磁盘上包含**一系列指令**的文件
- 进程是活动实体：具有程序计数器和相关**资源**，并且有开始、有结束的状态

当一个可执行文件（程序）被加载到内存中就成为进程，操作系统会为每一个进程分配资源，**进程是操作系统资源分配的基本单位**。

操作系统使用 **PCB**（process control block）来记录进程和静态程序所有的不一样（环境信息、分配的资源等）

### 进程的表示

PCB 是操作系统用于记录和刻画进程状态及环境信息的数据结构

借助 PCB 操作系统可以全面管理进程的物理实体，刻画进程的执行现状，控制进程的执行。

它包含许多与某个特定进程相关的信息：

- 进程状态：新的、就绪、运行、等待、停止
- 程序计数器：PC 寄存器的值，下个指令的地址
- CPU 寄存器：包括累加器、索引寄存器、堆栈指针、通用寄存器等信息
- CPU 调度信息：优先级、调度队列等信息
- 内存管理信息：例如基地址和界限寄存器的值，页表或段表
- 记账信息：CPU 时间、时间期限等信息
- I/O 状态信息：包括分配给进程的I/O设备列表、打开文件列表等

**进程实体：** 程序段、数据段、PCB 三部分组成了进程实体。

创建进程就是创建 PCB，撤销进程就是撤销 PCB，所以 PCB 是进程存在的唯一标志。

严格来说进程是进程实体的运行过程，是系统进行资源分配的单位。进程实体是静态的，进程是动态的。

### 进程状态

进程是一个活动的实体，在一个进程从开始到结束的过程中具有许多不同的状态

- 新的：进程正在被创建
- 运行：指令正在 CPU 上执行
- 等待：进程等待发生某个事件（阻塞状态）
- 就绪：进程等待分配 CPU
- 终止：进程已经执行完毕

进程的生命周期：

```mermaid
flowchart LR
new((新的)) --允许--> ready((就绪))
ready((就绪)) --调度器--> running((运行))
running((运行)) --中断--> ready((就绪))
running((运行)) --退出--> stop((终止))
running((运行)) --I/O或事件的等待--> wait((等待))
wait((等待))--I/O或事件的完成--> ready((就绪))
```

## 线程

![](/Users/xiefeng/Library/Application Support/typora-user-images/image-20220310213154616.png)

![](/Users/xiefeng/Library/Application Support/typora-user-images/image-20220310213227433.png)

![](/Users/xiefeng/Library/Application Support/typora-user-images/image-20220310213257246.png)

进程包括指令序列和分配的资源，进程的切换需要同时切换指令序列和与之分配的资源

能否将资源和指令执行分开，让一个进程由一份资源和多个指令执行序列组成，CPU 调度时**仅仅切换指令序列**而不切换资源，也就只需要修改寄存器，而分配的资源不需要动

也就是多个指令序列共享分配的资源（例如映射表），仅通过切换指令序列（PC），保留并发的优点， 减少进程切换的代价

### 线程的特点

- 每个线程拥有线程ID、线程控制块（TCB）
- 线程也有就绪、阻塞、运行三种状态
- 线程几乎不拥有系统资源
- 同一进程的线程共享进程资源
- 同一进程的线程通信无需操作系统干预
- 同一进程的线程切换不会引起进程切换
- 切换同一进程的线程开销比较小

### 用户级线程（ULT - user level thread）

用户级线程即在用户空间运行的线程，线程的创建和管理都由应用程序完成，内核感知不到用户级线程的存在。

线程的切换在用户态不需要进入内核，所以开销比较小，缺点就是无法利用多核，并且**一个线程的阻塞会造成整个进程的阻塞**。

**Jacketing 技术**

当一个用户级线程造成阻塞之后，将引起整个进程的阻塞，操作系统会进行进程调度，其他线程的存在失去了意义（没办法并发）

本质上就是操作系统无法感知用户级线程的存在，当进行阻塞的系统调用时，无法进行用户线程的切换

**jacketing 技术**就是通过修改操作系统，把阻塞式系统调用改造成非阻塞式

当陷入操作系统时执行 jacketing 程序，检查资源的使用情况，以决定执行进程切换或传递控制权给另一个线程，实现切换用户级线程

### 内核级线程（KLT - kenerl level thread）

线程管理的工作由操作系统内核来做，当一个线程阻塞时，内核就可以查找是否存在其他的线程并进行切换。

内核可以为每一个 CPU 分配一个线程，对于**多核 CPU**而言内核级线程的存在有很大的意义（同一个进程的不同线程分配不同的的核心）

应用程序线程在用户态运行，线程调度和管理在内核实现，调度时需要切换到内核，系统开销较大。

**支持内核级线程的意义**

现代 PC 大多是多核处理器，多核处理器是指在单个芯片上包含多个 CPU 的处理器，但是 cache、MMU 这些硬件每个核心是共享的

线程能够共享资源同时可以并发执行，为了能够充分利用硬件，操作系统需要能够支持内核级线程来充分利用 CPU 提高效率

![](/Users/xiefeng/Library/Application Support/typora-user-images/image-20220313100938151.png)

现代操作系统都支持内核级线程，所以说**线程是操作系统进行调度的基本单位**。

- **用户级线程解决了逻辑上并行性的问题。** 
- **内核级线程解决了物理上并行性的问题。** 

### 线程的实现

#### 用户级线程

只要有过程调用（函数调用）就需要用到栈来存储调用过程，所以**实现用户级线程的核心是每个线程都各自对应一个栈**

还需要类似于 PCB 的结构（TCB） 来保存每个线程当前执行的 CPU 环境，与该线程对应的栈相关联

用户级线程是在用户空间创建和管理线程，所以函数调用栈和 TCB 都保存在用户空间

#### 核心级线程

内核级线程的创建和调度等管理都是由内核来实现，所以 TCP 存储在内核空间中进行管理

核心级线程主要的代码还是在用户空间执行，所以在用户空间中还是需要对应一个栈

一个很重要的变化是每个线程都会执行系统调用，进入内核态执行时也会有相应的函数调用，所以每个线程会对应一个内核中的栈，用于存储用户空间中栈的地址和用于内核中的函数调用

即每一个内核级线程都对应一套栈，且 **TCB 关联内核栈，内核栈关联用户栈** 

所以说内核栈是必须的，即使没有内核级线程，每个进程也会对应一个内核栈，只不过有了内核级线程每个线程都会对应一个

**用户栈和内核栈的切换**

1. 进程/线程陷入内核态后，先把用户态堆栈的地址保存在内核栈之中，然后设置堆栈指针寄存器的内容为内核栈的地址，这样就完成了用户栈向内核栈的转换
2. 进程/线程从内核态恢复到用户态时，在内核态之行的最后将保存在内核栈里面的用户栈的地址恢复到堆栈指针寄存器，这样就实现了内核栈和用户栈的互转

## 多线程模型

### 混合策略

考虑到用户级线程和内核级线程的优缺点，可以使用混合策略实现效率较高的多线程，将用户级线程映射成内核级线程，通过调整内核级线程的数目可以很好的解决问题。

线程的创建、调度和同步在用户空间中进行，内核只调度内核级线程。

### 多对一模型

多个用户线程映射为一个内核线程，每个进程只对应一个内核线程。

优点：线程的切换在用户空间即可完成，开销小

缺点：当一个线程阻塞之后，整个进程都被阻塞；多个线程无法利用多核 CPU 并发执行

![](https://xf-blog-imgs.oss-cn-hangzhou.aliyuncs.com/img/image-20201220154804070.png)

### 一对一模型

一个用户线程映射为一个内核线程，每个进程拥有和它线程数量相同的内核线程。

优点：当一个线程阻塞以后，其他线程可以继续执行；也可以充分利用多核 CPU 并发执行

缺点：一个线程对应一个内核线程，线程的切换都有操作系统内核完成，线程管理成本高，开销大

![](https://xf-blog-imgs.oss-cn-hangzhou.aliyuncs.com/img/image-20201220155359230.png)

### 多对多模型

n 个用户线程映射到 m 个内核线程（n >= m)

克服了多对一并发度不高的缺点，也克服了一对一中一个进程占据过内核线程开销大的缺点。

![](https://xf-blog-imgs.oss-cn-hangzhou.aliyuncs.com/img/image-20201220155544968.png)





























## 进程运行

大多数操作系统的进程可以并发执行，它们可以动态的创建和删除。

### 进程的创建

进程在执行过程中可以创建多个新的进程，创建进程称为父进程，新的进程称为子进程。每个新进程可以在创建其他进程，从而形成进程树。

大多数操作系统对每个进程都分配一个**进程标识符**（pid），可以用作索引，以便访问内核中的进程的各种属性。

**进程表：**

内核负责管理维护所有进程，为了管理进程内核在内核空间维护了一个称为进程表的数据结构，这个表中中记录了所有的进程，索引为 pid，表项位 PCB。

一般来说，当一个进程创建子进程时，该子进程会需要一些资源来完成任务。这些资源可以来源于操作系统也可以从父进程获得。

当进程创建新进程时，有两种执行可能：

1. 父进程和子进程并发执行
2. 父进程等待，直到某个或全部子进程全部执行完

新进程的地址空间也有两种可能：

1. 子进程是父进程的复制品（具有与父进程同样的程序和数据），Linux 下通过 fork 创建子进程
2. 子进程加载另一个新程序，Linux 下通过 fork 创建完子进程接着使用 exec 加载新的程序到子进程的内存空间

### 进程终止

当进程完成执行最后语句并通过系统调用 `exit()` 请求操作系统删除自身，进程终止。这时进程可以返回状态值到父进程（通过系统调用 `wait()`）。

进程通过适当的系统调用可以终止另一进程，只有终止进程的父进程才可以执行这一系统调用，因此当一个进程创建新进程时，新创建进程的标识符要传递到父进程。

有些系统不允许子进程在父进程已终止的情况下存在，这称为**级联终止**。

当一个进程终止时，操作系统会释放其资源。不过它位于进程表中的条目还是存在，直到父进程调用 `wait()`。

> 在 unix/linux中，正常情况下，子进程是通过父进程创建的，子进程在创建新的进程。子进程的结束和父进程的运行是一个异步过程,即父进程永远无法预测子进程 到底什么时候结束。 当一个 进程完成它的工作终止之后，它的父进程需要调用wait()或者waitpid()系统调用取得子进程的终止状态。

**僵尸进程：** 一个进程使用fork创建子进程，如果子进程退出，而父进程并没有调用 `wait` 或 `waitpid` 获取子进程的状态信息，那么子进程的进程描述符仍然保存在系统中。

**孤儿进程：** 一个父进程没有调用 `wait` 就退出，而它的一个或多个子进程还在运行，那么那些子进程将成为孤儿进程。Linux 和Unix孤儿进程将被 init 进程收养，并由 init 进程对它们完成状态收集工作





## 进程通信

操作系统内并发执行的进程可以是独立的也可以是协作的。

协作进程需要**进程间通信（IPC）**机制，以允许进程相互交换数据和信息。进程间通信有两种基本模型：共享内存和消息传递。

对具有多个处理核系统的最新研究表明：在这类系统上，消息传递的性能要优于共享内存。共享内存会有高速缓存一致性问题，这是由于共享数据在多个高速缓存之间迁移而引起的。

### 共享内存

采用共享内存的进程间通信，需要通信进程建立共享内存区域。通常，一片共享内存区域驻留在创建共享内存段的进程地址空间内。其他希望使用这个共享内存段进行通信的进程应将其附加到自己的地址空间。

生产者 — 消费者问题是协作进程的通用范例。解决该问题的方法之一是采用共享内存。为了允许生产者进程和消费者进程并发执行，需要一个可用的缓冲区，以被生产者填充和被消费者清空。这个缓冲区驻留在共享内存区域内，而且生产者和消费者必须同步，这样消费者不会试图消费一个尚未生产出来的项。

**缓冲区类型**

- 无界缓冲区
- 有界缓冲区

### 消息传递

消息传递机制提供一种机制，以便允许进程不必通过共享地址空间来实现通信和同步。

使用原语 send() / receive() 来实现通信

**直接通信**

- send(p, message)：向进程 p 发送 message
- receive(p, message)：从进程 p 接收 message

**间接通信**

通过邮箱或端口来发送和接收消息，邮箱可以抽象成一个对象，进程可以向其中存放/删除消息，每个邮箱都有一个唯一的标识符

- send(A, message)：向邮箱 A 发送 message
- receive(A, message)：从邮箱 A 接收 message

邮箱可以为进程 / 操作系统所拥有，如果邮箱为进程所拥有，则每需要区分所有者和使用者。如果邮箱为操作系统所拥有，则操作系统则需要提供机制以便进程：创建新的邮箱、通过邮箱发送/接收信息、删除邮箱。

进程间通信可以通过调用原语 `send()` 和 `receive()` 来进行，消息传递可以是同步也可以是异步的。

- 阻塞发送：发送进程阻塞，直到消息由接收进程/邮箱接收
- 非阻塞发送：发送进程发送消息，然后恢复操作
- 阻塞接收：接受进程阻塞，直到有消息可用
- 非阻塞接收：接收进程收到一个有效消息/空消息

### 管道

管道允许两个进程进行通信，管道是早期 Unix 系统最早使用的一种 IPC 机制。

**普通管道**

普通管道允许两个进程按标准的生产者 — 消费者方式进行通信：生产者向管道的一端写，消费者从管道的另一端读。因此普通管道是单向的。

普通管道只能由创建进程所访问，通常情况下，父进程创建一个管道，并使用它来与子进程进行通信。

**命名管道**

命名管道提供了一个更强大的通信工具，通信可以双向但是是半双工，父子关系不是必须的。当建立了一个命名管道之后，多个进程都可用它通信。



# 进程调度

> CPU 调度是多道程序操作系统的基础，多道程序的目标是，无论何时都有进程运行，从而最大化 CPU 利用率。

对于支持线程的操作系统内核实际上调度的是线程。

## 调度层次

进程在整个生命周期中，会在各种调度队列之间迁移，操作系统通过调度程序来实现调度。

**调度程序的功能：**

- 切换上下文
- 切换到用户模式
- 跳转到用户程序的合适位置，重新启动程序

**调度延迟：** 调度程序停止一个进程而启动另一个所需的时间。

### 长期调度

> 对于批处理系统，提交的作业可以多于可以执行的，这些作业会被保存到大容量存储设备的缓冲池（后备队列），以便后续执行。

**长期调度**用于确定把后备队列上的哪些作业调入内存，并为之建立进程（PCB），分配其所需的资源然后将它挂在就绪队列上。

长期调度程序执行并不频繁，只有在进程离开系统（运行结束）才需要长期调度程序调度。

长期调度程序需要认证的选择合理的 I/O 密集型程序和 CPU 密集型程序的组合，让系统的性能最佳。

```mermaid
sequenceDiagram
磁盘 -->> 内存: 作业
Note right of 磁盘: 创建进程
```

进程状态的变化：

```mermaid
flowchart LR;
无 --> 创建态--> 就绪态
```



### 短期调度

> 短期调度程序 也叫 CPU 调度程序

短期调度程序的任务是从准备执行的进程中（就绪）选择进程，并分配 CPU。

短期调度程序需要经常为 CPU 选择新的进程，所以短期调度程序必须要快。

```mermaid
sequenceDiagram
内存 -->> CPU: 程序
Note right of 内存: 占据
```

进程状态变化：

```mermaid
flowchart LR;
就绪态 --> 运行态
```

### 中期调度

中期调度程序的任务是决定哪些进程被允许驻留在主存中参与处理器和其他资源的竞争，降低多道程序程度。

进程之后也可以被重新调入内存，并从中断处继续执行，这种方案叫交换。

PCB 依旧会留在内存中，因为需要依靠 PCB 来记录进程在外存中的位置，PCB 会处于挂起队列中。

中期调度程序做的就是执行换入、换出操作，被换出的进程状态变为**挂起**状态。

```mermaid
sequenceDiagram
内存 -->> 磁盘: 进程1
Note right of 内存: 换出 (swap out)
磁盘 -->> 内存: 进程2
Note right of 内存: 换入 (swap in)
```

进程状态变化：

```mermaid
flowchart LR;
挂起态 --> 就绪态
```

## 调度分类

**非抢占式调度：**一个进程分配到 CPU，直到终止或切换状态才会放弃 CPU。

**抢占式调度：** 一个进程被动的放弃 CPU，由于时间片用完或者有其他紧急的事等情况。

**调度准则：**

- CPU 使用率：CPU 忙碌的时间占总时间的比例。
- 吞吐量：单位时间内进程完成的数量。
- 周转时间：从进程提交到进程完成的时间。
- 等待时间：进程在就绪队列中等待的时间之和。
- 响应时间：从提交到产生第一响应（开始响应）的时间。

## 调度算法

- 先到先服务（FCFS）

- 最短作业优先（SJF）

	- 非抢占式
	- 抢占式：最短剩余时间优先（SRTN）

- 优先级

	会发生低优先级无穷等待（由于抢占），老化（增加等待时间长的优先级）可以解决。

- 轮转（RR）

	- 定义一个较小时间单元（时间片）
	- 就绪队列为循环队列
	- 每个进程分配不超过一个时间片的 CPU
	- RR 的平均等待时间通常比较长
	- 时间片应远大于上下文切换时间

- 多级队列

  - 就绪队列分成多个队列
  - 进程根据进程属性永久分配队列
  - 每个队列有自己的调度算法
  - 队列之间可以有优先级 / 队列之间可以划分时间片等

- 多级反馈队列

	- 允许进程在队列之间迁移（阻止饥饿的发生）
	- 进程使用过多 CPU 则会被移动到低优先级的队列
	
	