# 机器语言

机器指令：一台机器可以正确执行的命令。

电子计算机的机器指令是一列二进制数字，计算机将其转变为一列高低电平，驱动计算机的电子器件。

早期计算机的概念：能够执行机器指令进行运算的机器。

现在的 PC 中 CPU 完成了这个整个功能，CPU 是一种微处理器。现在的计算机是指由 CPU 和受 CPU 直接或间接控制的芯片、期间、设备组成的计算机系统。

机器语言：每一种微处理器由于硬件设计和内部结构不同，需要用不同的电平脉冲来控制，所以每一种微处理器都有自己的机器指令集，也就是机器语言。

# 汇编语言

汇编指令是机器指令便于记忆的书写格式，和机器指令是一一对应的。

汇编语言的组成：

- 汇编指令：机器码的助记符，有对应的机器码
- 伪指令：没有对应的机器码，由编译器执行
- 其他符号：由编译器识别，没有对应的机器码

源程序的执行过程：

1. 使用编辑器用汇编语言编写源程序
2. 对源程序进行编译链接
	1. 编译程序对源程序进行编译，产生目标文件
	2. 连接程序对目标文件进行连接，生成可在操作系统中直接执行的可执行文件

可执行文件包含两部分：

1. 程序和数据，从汇编指令翻译过来的机器码、源程序中定义的数据
2. 相关的描述信息，比如程序有多大、占用多大内存空间

**必要的一些伪指令**

segment

  segment 和 ends 是一对成对使用的伪指令，功能是定义一个段。

  一个汇编程序是由多个段组成的，一个有意义的汇编程序至少要有一个段。

  ```assembly
  段名 segment
  ...
  段名 ends
  ```

end

- end 是一个汇编程序的结束标记，编译器在编译程序的过程中，碰到 end 伪指令，结束编译。
- end 除了通知编译器程序结束之外，还可以告诉编译器程序的入口在什么地方。

具体的过程：编译器最后生成的可执行文件中的描述信息中就会包含程序的入口地址，当可执行文件被载入内存中，加载可执行文件到内存执行的程序就会从描述信息中读取到入口地址从而设置 CS:IP 指向该地址。

assume

assume 是假设，它假设某一段寄存器和程序中某一个段相关联。在需要的情况下，编译器可以将段寄存器和某一个具体的段相联系。

> CPU 怎么处理我们定义的各个段中的内容，是当数据还是当指令还是当栈空间，都是依据我们程序中具体的指令对 CS:IP、SS:SP、DS 等寄存器值的设置来决定的。

```assembly
assume cs: code ; cs 段寄存器和 code 段相关联
code segment
...
code ends
end
```

**标号**

一个标号指代了一个地址，例如 code 段，code 指代了这个段的起始地址。

标号最终会被编译、连接成为一个地址。

**程序返回**

一个程序结束之后，需要将 CPU 的控制权交还到使它得以运行的程序，这个过程称之为：**程序返回**

在汇编程序的末尾加上两行就可以实现程序返回：

```assembly
mov ax,4c00H
int 21H
```

# 段

内存本身并不会分段，段的划分来自于 CPU。我们可以通过分段的方式来管理内存。

在编程时可以根据需要，将若干地址连续的内存单元看作一个段，通过段地址和偏移地址来定位内存单元。

**代码段：**我们可以将长度为 N 的一组地址连续，起始地址为 x 的内存单元专门存储指令，从而定义了一个代码段。

**数据段：**我们可以将长度为 N 的一组地址连续，起始地址为 x 的内存单元专门存储数据，从而定义了一个数据段。

**栈段：**我们可以将长度为 N 的一组地址连续，起始地址为 x 的内存单元当作栈来使用，从而定义了一个栈段。

CPU 并不会感知到我们的这种安排，依旧是通过 CS:IP 指向当前执行指令的地址，SS:SP 指向栈顶地址，DS 指向数据的段地址，通过偏移地址来访问需要的数据。

将数据、代码、栈放入不同的段：

1. 将所有的数据、代码、栈空间，都放在一个段中程序显得比较混乱
2. 在 8086 模式下，一个段的容量不能大于 64KB（原因是：偏移地址使用 16 位，16位最多只能偏移 64KB 的内存地址）

# 段前缀

在访问内存单元时，偏移地址通过 `[bx]` 给出，段地址默认在 ds 寄存器中。

在访问内存时可以显示地给出段地址所在的段寄存器：

- `mov ax, ds:[bx]`
- `mov ax, cs:[bx]`
- `mov ax, ss:[bx]`
- `mov ax, es:[bx]`
- `mov ax, ss:[bx]`

显示地指令内存单元的段地址的 `ds:` 等，在汇编中称为 **段前缀**。

# 栈操作

8086提供了入栈和出栈的指令：

```assembly
push / pop 寄存器

push / pop 内存单元
```

- `push ax`：将 ax 中的数据入栈
- `pop ax`：将栈顶元素出栈放入 ax 

# 算数指令

## 加减指令

```assembly
add / sub 寄存器, 数据

add / sub 寄存器, 寄存器

add / sub 寄存器, 内存单元

add / sub 内存单元, 寄存器
```

## 乘除指令

除法指令（div）：

1. 除数：有 8 位和 16 位两种，存放在寄存器或内存中
2. 被除数：默认放在 AX 或 DX 和 AX 中。
	- 如果除数为 8 位，则被除数为 16 位，默认放在 AX 中
	- 如果除数为 16 位，则被除数位 32 位，默认放在 DX 和 AX 中，DX 中存放高 16 位，AX 中存放低 16 位
3. 结果：根据除数的位数不同，有两种情况
	- 如果除数为 8 位，则 AL 存储除法操作的商，AL 存储余数
	- 如果除数为 16 位，则 AX 存储商，DX 存储余数

```assembly
div reg ; 除数在寄存器

div 内存 ; 除数在内存中

div byte ptr ds:[0]
```

乘法指令（mul）：

1. 两个相乘的数：位数相同，要么都是 8 位，要么都是 16 位
	- 8 位：一个默认放在 AL 中，另一个放在 8 位寄存器或内存中
	- 16 位：一个默认放在 AX 中，另一个放在 16 位寄存器或内存中
2. 结果：
	- 8 位乘法：默认放在 AX 中
	- 16 位乘法：默认高位放在 DX 中，低位放在 AX 中

```assembly
mul reg

mul 内存

mul byte ptr ds:[0] ; 8 位乘法
```

# Loop指令

loop 指令格式：`loop 标号`

loop指令执行 CPU 的操作：

1. CX 寄存器的值减一
2. 判断 CX 寄存器的值是否为 0，
	- 不为 0 跳转到标号处执行
	- 为 0 则直接向下执行

使用汇编计算 $2^3$：

```assembly
move ax,2 ; 2 ^ 1
add ax,ax ; 2 ^ 2
add ax,ax ; 2 ^ 3

; 使用 loop 
   move ax,2
   move cx, 2 ; add ax,ax 2 次
s: add ax,ax
   loop s;
```

执行 `loop s` 只会执行 cx -1 次，还有一次是顺序执行到 s 的位置时执行的。

使用 loop 和 cx 配合实现循环的要点：

1. CX 寄存器的值为循环次数
2. loop 指令的标号地址要在 loop 指令之前
3. 循环执行的程序段，写在标号和 loop 之间

```assembly
; 循环框架
   mov cx, 循环次数
s: 程序段
   loop s
```

# 寻址方式

在 8086 CPU 中，只有 bx，si，di，bp 四个寄存器可以通过 `[bx]` 进行内存单元的寻址。

si 和 di 是 8086 中和 bx 功能相近的寄存器，唯一的区别是：si 和 di 不能分为两个 8 位寄存器使用

bp 相当于 bx 寄存器，区别是当寻址时没有使用段前缀显示的给处段地址，段地址默认在 SS 段寄存器中。

所有寻址方式：

- `[idata]`
	- 直接寻址
	- 在没有段前缀的时候，masm 编译器会将 `[idata]` 解释为 idata
- `[bx]`、`[di]`、`[si]`、`[bp]`
	- 寄存器间接寻址
	- bx、di、si 默认段寄存器为 ds，bp 默认段寄存器为 ss
- `[bx + idata]`、`[di + idata]`、`[si + idata]`、`[bp + idata]`
	- 寄存器相对寻址
	- 偏移地址的值为 `bx + idata`
	- 其他写法：
		- `idata[bx]`
		- `[bx].idata`
		- `[bx][idata]`

- `[bx + si]`、`[bx + di]` / `[bp + si]`、`[bp + di]`
	- 基址变址寻址
	- 偏移地址的值为 `bx + si`
	- 其他写法：`[bx][ax]` 
- `[bx + si + idata]`、`[bx + di + idata]` / `[bp + si + idata]`、`[bp + di + idata]`
	- 相对基址变址寻址
	- 偏移地址的值为 `bx + si + idata`
	- 其他写法：
		- `idata[bx][si]`
		- `[bx].idata[si]`
		- `[bx][si].idata`

# 数据处理

绝大部分的机器指令都是进行数据处理的指令，大致课分为三类：读取、写入、运算。

在机器指令的层次来说，并不关注数据的值具体是多少，关心的而是在指令执行前，所需要处理的数据所在的位置。

为什么不是指令执行时，数据所在的位置，因为在执行时数据已经被调入 CPU 中的寄存器中。

在指令执行前，需要处理的数据可以在 3 个位置：CPU 内部、内存、端口。

**数据位置在汇编中的表达：**

1. 立即数：直接包含在机器指令中的数据，指令执行前在 CPU 的指令缓冲器中
2. 寄存器
3. 段地址和偏移地址

**处理数据的长度**

8086 可以处理两种长度的数据：byte 和 word。在指令中需要指明指令处理的是字节还是字。

指明方式：

1. 通过寄存器名指明：指令中的寄存器是 16 位就是字操作，寄存器为 8 位就是字节操作
2. 在没有寄存器时，通过操作符 x ptr 指明：`word ptr` 或 `byte ptr`

```assembly
move ax, ds:[0] ; 字操作

move al, ds:[0] ; 字节操作

move word ptr ds:[0], 1 ; 字操作

mov byte ptr ds:[0], 1 ; 字节操作
```

# 伪指令

- `db`：define byte 定义字节型数据
- `dw`：define word 定义字型数据
- `dd`：define double word 定义双字型数据

```assembly
data segment
  db 1	; 多个数据用 , 分隔 db 1,2,3
  dw 1
  dd 1
data ends
```

data段定义了3个数据：`01H`、`0001H`、`00000001H`，位置分别为：`data:0`、`data:1`、`data:3`

在汇编程序中，可以使用 `'....'` 的方式指明数据是以字符的形式给出：

```assembly
assume ds:data
data segment
  db 'unIX'
  db 'foRK'
data ends
```

`db 'unIX'` 相当于 `db 75H,6EH,49H,58H`，`unIX` 的 ASCII 码分别为：75H、6EH、49H、58H

**dup 操作符**

和db、dw、dd一样，也是由编译器识别和处理的符号。

dup 用于和 db 等指令配合，用来进行数据的重复。

- `db 重复次数 dup(重复的字节型数据)`
- `dw 重复次数 dup(重复的字型数据)`
- `dd 重复次数 dup(重复的双字型数据)`

```assembly
db 3 dup(0) ; --> db 0, 0, 0

db 3 dup(0, 1, 2) ; --> db 0,1,2,  0,1,2,  0,1,2

db 3 dup('abc', 'ABC') ; --> db 'abc','ABC',  'abc','ABC',  'abc','ABC'
```

# and、or指令

and：逻辑与指令，按位与运算

```assembly
mov al, 01100011B
add al, 00111011B ; al: 00100011B
```

or：逻辑或，按位或运算

```assembly
mov al, 01100011B
or  al, 00111011B ; al: 01111011B
```

**程序中经常需要进行数据的暂存，怎样做更为合理？**

1. 数据可能存在于寄存器中，也可能存在于内存中
2. 寄存器暂存不是一个一般化的方案，因为寄存器的数量有限
3. 每个程序中可以使用的寄存器都不一样

不能选择寄存器，只能使用内存来暂存数据了。一般来说，在需要暂存数据的时候，我们都应该使用**栈**，比较方便。

# 转移指令

可以修改 IP，或同时修改 CS 和 IP 的指令统称为转移指令。

8086 的转移行为有：

- 段内转移，只修改 IP，例如：`jmp ax`
- 段间转移，同时修改 CS 和 IP，例如：`jmp 1000:0`

段内转移由于对 IP 修改范围不同分为：

- 短转移，IP 的修改范围为 -128 - 127，也就是 8 位
- 近转移，IP 的修改范围为 -32768 - 32767，也就是 16 位

8086 转移指令分为：

- 无条件转移
- 条件转移
- 循环
- 过程
- 中断

## offset

offset 是一个汇编操作符，功能是**取得标号的偏移地址**。

```assembly
assume cs: code
code segment
	start: mov ax, offset start	; ---> mov ax, 0
		s: mov ax, offset s		; ---> mov ax, 3
code ends
end start
```

## jmp

jmp 指令为无条件转移指令，可以只修改 IP，也可以同时修改 CS 和 IP。

jmp 可以给出两种信息进行跳转：

- 跳转的目的地址
- 跳转的距离

jmp 指令所对应的机器码，是不存在转移的目的地址的，存在的是执行跳转指令时 IP 和目的地址之间的位移。

这个位移式编译器根据汇编指令中的标号计算出来的。

位移的计算方法：标号处的地址 - jmp指令后的指令的第一个字节的地址。

为什么是后一个指令的起始地址，因为 CPU 执行指令的过程是：

1. 从 CS:IP 指向的内存单元取指令，进入指令缓冲器
2. IP += 指令长度
3. 执行指令

在真正执行指令时，IP 的指向已经指向了下一个地址，所以跳转的偏移量就需要从下一个指令起始地址计算，而不是jmp指令的起始地址

所以下面的汇编编译成机器指令是这样的：

```assembly
assume cs: code 
code segment
	start: mov ax, 0	; B8 00 00
		   jmp short s	; EB 03
		   add ax, 1	; 05 01 00
		s: inc ax		; 40
code ends
end
```

EB 对应的就是 jmp short 指令，03 就是 IP 需要向后移动三个字节

- `jmp short 标号`：段内短转移
- `jmp near ptr 标号`：段内近转移
- `jmp 16位寄存器`：段内转移，仅修改 IP 
- `jmp word ptr 内存`：段内转移，仅修改 IP
- `jmp dword ptr 内存`：段间转移，高地址处的字是段地址，低地址处的字是偏移地址

## jcxz

jcxz 指令为有条件转移指令，所有的条件转移指令都是短转移。

语法：`jcxz 标号`

当 cx 寄存器的值为 0，转移到标号处执行，就相当于：

```c
if (cx == 0) {
    jmp short 标号;
}
```

## loop

loop 指令也是短转移，在机器码中对应的也是转移的位移，而不是地址。

loop 的执行过程：

```c
...
if (--cx != 0) {
    jmp short 标号;
}
...
```

**根据位移跳转的意义**

这些跳转指令对 IP 的修改都是通过目的地址和起始地址之间的**位移**来进行的，在机器码中不包含目的地址，只包含位移。

这种设计，方便了程序段在内存中的浮动装配。

如果采用严格的目的地址来转移，当程序载入内存中时，标号处的指令的实际地址未必就是理论上的地址。如果采用位移，在逻辑上的偏移无论标号处的指令的实际地址为多少，都是能够正确执行的。

## ret

- ret 指令使用栈中的数据，修改 IP 的内容，从而实现近转移。

- retf 指令使用栈中的数据，修改 CS 和 IP 的内容，从而实现远转移。

ref 指令相当于：

```assembly
pop IP
```

reft 指令相当于：

```assembly
pop IP
pop CS
```

## call

CPU 执行 call 指令时，进行两步操作：

1. 将当前 IP 或 CS 和 IP 压入栈中
2. 执行跳转操作

- `call 标号`：将当前的 IP 入栈，段内跳转
- `call far ptr 标号`：将当前的 CS、IP 依次入栈，段间跳转
- `call 16位寄存器`：将 IP 入栈，段内跳转
- `call word ptr 内存`：将 IP 入栈，段内跳转
- `call dword ptr 内存`：将 CS、IP 入栈，段间跳转

call 指令相当于先 `push IP` 或 `push CS` 和 `push IP` 保存当前的地址，再接着使用相对应的 jmp 进行跳转。

# 子程序

子程序：一个具有一定功能的程序段，就相当于函数，或者说函数就来相当于子程序。

call 和 ret 指令配合可以用来实现子程序的设计，也就是支持了汇编语言中的模块化设计。

具体的过程就是：在需要执行子程序的时候，使用 call 指令跳转执行，执行完可在子程序中调用 ret 指令返回接着往下执行。

**参数和结果的传递**

子程序一般都需要根据提供的参数处理一定的事务，处理后将结果返回给调用者。

如何存储子程序需要的参数和产生的返回值？

寄存器的数量终究有限，不可能简单的使用寄存器来存放多个需要传递的数据和返回值。

比较通用的方式是使用栈来传递参数。

**寄存器冲突问题**

子程序实现某些功能时，必定需要用到一些寄存器，但是调用者也可能会使用这些寄存器。

无论是调用者避免使用子程序用到的寄存器，还是子程序去避免冲突（子程序不应当关注调用者，也没有办法知道将来的调用情况）都不可行。

比较简单的解决办法就是：子程序在开始时就将需要用到的寄存器中的内容通过**栈**保存起来，在返回之前恢复一下。

编写子程序额标准框架：

```assembly
子程序开始: 子程序中使用到的寄存器全部入栈
		   子程序处理流程
		   子程序中使用的寄存器全部出栈
		   返回（ret / retf）
```

# adc指令

adc 是带进位加法指令，利用了 CF 标志位伤记录的进位值

```assembly
adc ax, bx ; ax = ax + bx + CF
```

意义：CF 可以保存进位的值，利用 add和 adc 指令相配合可以对更大的值（大于16位）进行加法运算。

因为加法可以分为两步：1. 低位相加 2. 高位相加再加上地位相加的进位值

```assembly
; 1E F000H + 20 1000H
mov ax, 001EH	; 高16位
mov bx, 0F00H	; 低16位

add bx, 1000H	; 低位相加
add ax, 0020H	; 高位相加再加上进位值	ax存高位，bx存低位
```

# sbb指令

sbb 是借位减法指令，利用了 CF 标志位伤记录的借位值，和 adc 类似，使用 sbb 与 sub 配合可以实现对任意大的数据进行减法运算。

# cmp指令

cmp 比较指令，功能相当于减法指令，但是不保存结果，却影响标志寄存器。

```assembly
cmp ax, ax ; ax - ax = 0 ->  ZF=1 PF=1 SF=0 CF=0 OF=0
```

通过 cmp 指令之后，相关标志位的值就可以判断比较的结果：

```assembly
cmp ax, b
```

- zf = 1：ax = bx
- zf = 0：ax != bx

对于无符号数，可以直接通过 CF 标志位来判断两个数的大小

对于有符号数，需要通过 SF 标志位和 OF 标志位结合来判断有符号数是溢出以及结果的正负来判断两个数的大小

# 串传送指令

movsb：传送一个字节，将 ds:si 指向的内存**字节**单元中的数据送入 es:di 中

用汇编来描述：

```assembly
mov es:[di],  byte ptr ds:[si]

df == 0:
	inc si
	inc di
df == 1:
	dec si
	dec di
```

movsw：传送一个字，将 di:si 指向的内存**字**单元中的数据送入 es:di 中

用汇编来描述：

```assembly
mov es:[di],  word ptr ds:[si]

df == 0:
	add si, 2
	add di, 2
df == 1:
	sub si, 2
	sub di, 2
```

movsb 和 movsw 只进行一次传送，一般这两个指令需要和 rep 配合：

```assembly
rep movsb
```

该指令相当于：

```assembly
s: movsb
   loop s
```

rep 指令就是根据 cx 的数值，传送一定的次数。

pushf 和 popf：将标志寄存器的值压栈，和将栈中标志寄存器的值弹出

# 特殊的标号

```assembly
code segment
	a db 1,2,3,4,5,6
	b dw 0
code ends
```

标号 a 和 b，后面没有 `:`，它们同时描述了内存地址和数据的单元长度，使用这种标号时可以省略 `word ptr` 和 `byte ptr`

a 不仅标识了地址 `code:0`，还标识了这个地址开始的内存单元都是字节单元

`seg` 操作符，功能为取得一个标号的**段地址**

```assembly
data segment
	a db 1,2,3,4,5
	seg a
data ends
```



