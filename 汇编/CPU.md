# 寄存器

对于一个汇编程序员来说，CPU 中主要的部件是寄存器。寄存器是程序员可以用指令读写的部件，通过控制寄存器来控制 CPU。

8086 有14个寄存器：AX、BX、CX、DX、SI、DI、SP、BP、IP、CS、SS、DS、ES、PSW。

8086 的寄存器都是16位的，而上一代 CPU 的寄存器都是8位的；

为了保证兼容，8086 的 AX、BX、CX、DX 寄存器每个都可以拆分为独立的 2 个寄存器来使用。

- AX可以分为 AH 和 AL
- BX可以分为 BH 和 BL
- CX可以分为 CH 和 CL
- DX可以分为 DH 和 DL

L 代表低8位，H代表高8位：

![](http://oss.xiefeng.tech/img/20210516152518.png)

# CPU位数

> 字长是指计算机内部参与运算的数的位数。它决定着计算机内部寄存器、ALU和数据总线的位数，直接影响着机器的硬件规模和造价。

8086是16位结构 CPU，16位结构代表的意义：

1. 运算器一次最多可以处理 16 位的数据
2. 寄存器的最大宽度为 16 位
3. 寄存器和运算器之间的通路为 16 位
4. 字长为 16 位
5. 数据总线宽度 16 位

# 寻址方式

CPU 的位数和地址总线的宽度没关系，8086是16位 CPU，地址总线的宽度为 20，达到了 1M 寻址能力。

寻址能力：存储器的每个存储单元都能存储 1 Byte，1 位宽度的地址总线的寻址能力为 2 个存储单元 => 2 B

8086CPU的寻址能力：$2^{20}=2^{10}*2^{10} B = 2^{10} KB = 1 M$

8086为16位结构，如果简单的直接将地址从内部简单的发出，那么寻址能力就只有 16 位所能达到的 64 KB。

8086采用一种在内部使用两个16位地址合成的方法来形成一个20位物理地址。

![](http://oss.xiefeng.tech/img/20210516112515.png)

地址加法器采用 `物理地址 = 段地址 * 16 + 偏移地址` 的方式合成物理地址。

这种寻址方式的本质含义：CPU 在访问内存时，将基础地址和偏移地址相加，得到内存单元的物理地址

# 段寄存器

8086通过段地址和偏移地址形成物理地址，段地址存储在段寄存器中。

8086具有4个段寄存器：CS、DS、SS、ES。

## 代码段

- CS：代码段寄存器（code segment）
- IP：指令指针寄存器（instruction pointer）

PC 和 CS:IP 的区别：PC是计算机科学中的一个术语，CS 和 IP 是 x86 兼容 CPU 上实现 PC 的具体措施。

在 8086 机中，CS:IP 指向当前执行的指令。

8086 CPU工作过程：

1. 从 CS:IP 指向的地址读取指令，读取的指令进入**指令缓冲器**
2. IP = IP + 指令长度，从而指向下一条指令
3. 执行指令，接着重复过程

更改 CS、IP 的值：8086 中 `mov` 指令可以更改大部分寄存器的值，但对于 CS 和 IP 只能通过 `jmp` 指令更改

- `jmp 段地址:偏移地址`
- `jmp 合法寄存器`：仅修改 IP 的值

```assembly
jmp 2AE3:3 ; CS = 2AE3 IP = 0003

jmp ax ; IP = ax
```

**CPU 如何知道指令的长度：**

> 实际上是在设计cpu芯片时，就要考虑设计什么样的指令，指令长度，执行时间，影响哪些寄存器，然后给每个指令一个二进制码，当执行到某个指令的第一个字节时（或者更多更细分）就识别出是什么指令了，芯片硬件做相应的动作。

![](http://oss.xiefeng.tech/img/20210529201835.png)

## 数据段

CPU 要读写一个内存单元时，必须先给出这个内存单元的地址。

8086中，内存地址由段地址和偏移地址组成，8086中有一个 DS 寄存器，存放需要访问的数据的段地址。

8086不支持将数据直接送入段寄存器的操作，所以需要通过其他寄存器来辅助。

偏移地址通过 `[x]` 给出

```assembly
mov bx,1000H
mov ds,bx
mov al,[0]
```

## 栈段

SS：栈顶的段地址

SP：栈顶的偏移地址

在任意时刻 SS:SP 指向栈顶元素，在执行 push 和 pop 指令时，CPU 从 SS 和 SP 获取到栈顶地址。

# 字的存储

8086寄存器可以存下一个字，但是内存单元是字节单元，一个字需要用两个地址连续的内存单元来存放。

字单元：存放一个字型数据的内存单元，即由两个地址连续的内存单元组成。

N地址字单元：起始地址为N的字单元。

任何两个连续的内存单元，可以将它们看成两个内存单元，也可看成一个地址为 N 的字单元。

`mov` 指令可以在寄存器和内存之间进行字数据传送，由于 8086 的数据总线宽度为 16，可以一次性传递一个字。

# 内存地址空间

一台 PC 上会装有多个存储器芯片，例如：RAM、ROM、显卡的 RAM

PC 上的所有存储器，在物理上是独立的期间，但是都和 CPU 的总线相连，CPU 都是通过控制线发出读写命令。

CPU 在操纵它们的时候，将它们当作一整块逻辑存储器来使用，每个物理存储器在这个逻辑存储器中占一个地址段。

# 栈机制

CPU 提供了相关的指令**以栈的方式**访问内存空间，在基于8086编程时，可以将一段内存当作栈来使用。

栈顶为低地址部分，栈底为高地址部分。

8086提供了入栈和出栈的指令：

- `push ax`：将 ax 中的数据入栈
- `pop ax`：将栈顶元素出栈放入 ax 

在任意时刻，SS:SP 指向栈顶元素，push 和 pop 执行执行时，CPU 都会从 SS 和 SP 中得到栈顶地址。

8086的入栈和出栈都是以字为单位进行的，初始化 SS:SP 时，SP 的地址应当设置为栈底 + 2

push 执行过程：

1. SP = SP - 2，即 SS:SP 指向新的栈顶单元
2. 将 push 的寄存器中的数据送入栈顶的内存单元中

pop 执行过程：

1. 将 SS:SP 指向的内存单元处的数据送入 pop 的寄存器内
2. SP = SP + 2，即 SS:SP 指向新的栈顶单元

8086不会保证我们对栈的操作是不会超界的，8086只知道栈顶在何处，不知道我们安排的栈空间有多大。

就像 CPU 只知道当前执行的指令在何处，而不知道有多少指令要去执行。

# 标志寄存器

标志寄存器是一种特殊的寄存器，它的作用有三种：

1. 存储相关指令的某些执行结果
2. 为 CPU 执行相关指令提供行为依据
3. 控制 CPU 的相关工作方式

标志寄存器中存储的信息通常被称为 PSW（程序状态字），可以设置一组控制与状态寄存器，也可以专设一个 PSW 寄存器。

8086 CPU 只有一个标志寄存器，这个寄存器 16 位每一位都有专门的含义，按位起作用。

但 8086 只使用了 0、2、4、6、7、8、9、10、11 这几位。

**相关指令：** 指的就是那些执行完会影响标志寄存器的指令，在 8086 中这些指令大都是运算指令（add、sub、and等），像 mov、push 等传送指令是不会影响标志寄存器的。

## ZF标志

ZF 是零标志位（zore flag），标志寄存器的第 6 位，它记录相关指令执行后结果是否为 0。

如果结果为 0，则该标志位值为 1；如果结果不为 0，则该标志位为 0。

```assembly
mov ax, 1
sub ax, 1 ; zf = 1

add ax, 1 ; zf = 0
```

## PF标志

PF 是奇偶标志位，标志寄存器的第 2 位，它记录相关指令执行后，其结果的所有 bit 位中 1 的个数是为偶数。

当结果中的 1 的个数为**偶数**，PF = 1，否则 PF = 0

```assembly
mov al, 1
and al, 10 ; al = 00001011B  PF = 0
```

## SF标志

SF 是符号标志位，标志寄存器的第 7 位，记录的是相关指令结束后，结果是否为负数。

在计算机中，都是用补码来存储数据，同样一个数据即可以看作是有符号数，也可以看成无符号数。

```assembly
mov al, 10000001B
add a1, 1 ; al = 10000010B
```

`10000010` 既可以看成无符号数 130，也可以看成 -126。

CPU 在进行运算的时候就包含了两种含义，但 CPU 做的仅仅就是补码的相加而已。

重要的是我们是如何看待的，是无符号数相加还是有符号数相加，CPU 应当用一种信息来记录，以便我们获取我们需要的结果。

SF 标志位记录的是 **有符号数** 运算结果是否为负数，就是将结果看作有符号数，该数是否为负数。

如果为负数，则 SF = 1；如果我们将数据当作 **无符号数**，则 SF 标志位对我们无意义。

```assembly
mov al, 10000001B
add a1, 1 ; SF = 1 
```

**add 等运算指令一定会影响到 SF 寄存器的值，即使我们用不上该寄存器的值。**

## CF标志

CF 是进位标志位，标志寄存器的第 0 位，记录了 **无符号数** 运算结果的最高有效位向更高位的进位制或借位值。

由于计算机中是二进制元素，进位和借位的值只能是 0 或 1。

```assembly
mov al, 98H
add al, al ; 98H + 98H = 130H = 1 0011 0000B al = 30H CF = 1
```

## OF标志

OF 是溢出标志位，标志寄存器的第 11 位，记录的是 **有符号数** 运算结果是否发生溢出。

如果发生溢出，OF = 1，否则 OF = 0

```assembly
mov al, 98
add al, 99 ; 98 + 99 = 197 = 11000101B = -72 OF = 1
```

## DF标志

DF 是方向标志位，用于控制在串处理指令中每次操作后 si、di 的增减。

DF = 0，每次操作后 si、di 递增；DF = 1，每次操作后si、di 递减。

8086 提供了两条指令对 DF 进行设置：

- cld：将 DF 设置为 0
- std：将 DF 设置为 1
