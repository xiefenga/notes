## 内存分配

在编译时**大小未知**或**大小可能变化**的数据都应该存储在堆上

入栈比在堆上分配内存要快，入栈无需搜索内存空间并且位置总是在栈顶，在堆上分配内存则需要搜寻并做记录

访问堆上的数据比访问栈上的数据慢，因为必须通过指针来访问进行跳转，而现代 CPU 由于 cache 的存在访问附近的内存会更加快

堆内存的使用场景：

1. 存放栈无法处理的内存（过大，或者长度不定，或者需要动态增长）
2. 在同一个调用栈中真正需要被多个数据结构共享
3. 在多个调用栈中共享 

## 所有权

rust 使用单一所有权来解决内存管理的问题

- 一个值进行了变量绑定，这个变量被称为该值的**所有者** 
- 一个值同一时刻只能有一个所有者
- 当所有者离开作用域时，其拥有的值也被丢弃
  - 栈内存被销毁
  - 堆内存被释放

```rust
{                      // s 在这里无效，它尚未声明
    let s = "hello";   // 从此处起，s 是有效的
    // 使用 s
}      								// 此作用域已结束，s不再有效
```

在这种单一所有权的约束下，堆内存的生命周期和其所对应的栈的生命周期保持一致，即指向该堆内存的栈空间被销毁，该堆内存也被释放，避免内存泄露的机会。

> 堆变量的生命周期不具备任意长短的灵活性，因为堆上内存的生死存亡，跟栈上的所有者牢牢绑定。而栈上内存的生命周期，又跟栈的生命周期相关，所以我们核心只需要关心调用栈的生命周期。

### Move 语义

Move 语义指的是变量赋值、参数传递、函数返回等行为，旧的所有者会把值的所有权转移给新的所有者，旧的所有者不再拥有所有权（即变量无法再使用），以保证单一所有者的约束。

```rust
let x = String::from("hello");
let y = x;  // value moved here
println!("{:?}", x); // value borrowed here after move
println!("{:?}", y);
```

Move 语义本质是栈内存的**浅拷贝**，和 Copy 语义的行为是相同的，只不过在 Move 语义下编译器会不再允许使用所有权已被转移的变量。

浅拷贝：仅仅对栈上内容的进行复制

深拷贝：栈以及栈所指向的堆上的数据都进行复制

### Copy 语义

Copy 语义即在发生赋值或者传参等行为时，值会自动按位拷贝，而不是进行所有权的转移

实现了 Copy trait 的类型在赋值时会自动使用 Copy 语义，而不是 Move 语义

```rust
let x = 10;
let y = x;
println!("{x} {y}"); 
```

使用 `drive(Copy)` 即可让一个类型实现 Copy trait，但是实现 Copy trait 需要先实现 Clone trait

rust 中 Copy trait 和 Drop trait 不能共存，保证了无法为一个在堆上分配内存的结构实现 Copy

要么不实现 Copy，要么不实现 Drop：

- 不实现 Drop，会导致内存泄漏，但它不会对正确性有任何破坏（不会出现 use after free 这样的问题）
- 不实现 Copy，就只能使用 Move 语义，确保内存安全



Copy trait 和 Drop trait 是互斥的，两者不能共存，当你尝试为同一种数据类型实现 Copy 时，也实现 Drop，编译器就会报错。这其实很好理解：Copy 是按位做浅拷贝，那么它会默认拷贝的数据没有需要释放的资源；而 Drop 恰恰是为了释放额外的资源而生的。

虽然 RawBuffer 可以实现 Copy trait，但这样一来就无法实现 Drop trait。如果程序非要这么写，会导致内存泄漏，因为该释放的堆内存没有释放。

但是这个操作不会破坏 Rust 的正确性保证：即便你 Copy 了 N 份 RawBuffer，由于无法实现 Drop trait，RawBuffer 指向的那同一块堆内存不会释放，所以不会出现 use after free 的内存安全问题



对于代码安全来说，内存泄漏危害大？还是 use after free 危害大呢？肯定是后者。Rust 的底线是内存安全，所以两害相权取其轻。

### Borrow 语义

Borrow 语义允许一个值在所有权不发生转移的情况下被其它上下文使用，也就是只有**临时使用权**但没有所有权

Borrow 语义通过引用语法（`&` 或者 `&mut`）来实现

Rust 下的所有的引用都只是借用了“临时使用权”，并没有破坏值的单一所有权约束

## 引用

**引用**（*reference*）就是一个指针，存储着所指向的那个值的地址，创建一个引用的行为称为**借用**（*borrowing*）

在 Rust 中“借用”和“引用”是一个概念，只不过和其他语言中引用的意义，便于区分所以提出了新概念“借用”

```rust
let x = 2;
assert_eq!(std::mem::size_of_val(&&x), std::mem::size_of::<usize>());
assert_eq!(std::mem::size_of::<&i32>(), std::mem::size_of::<usize>());
assert_eq!(std::mem::size_of::<&String>(), std::mem::size_of::<usize>());
```

不可变引用实现了 Copy trait，可变引用没有实现 Copy trait（因为不可以同时存在多个可变引用）

```rust
let mut y = 10;
let x = &mut y;
let z = x; // value moved here
println!("{} {}", x, z); // value borrowed here after move
```

### 和指针的区别

引用和指针是一个持有内存地址的值，可以通过解引用（dereference）来访问它指向的内存地址

- 指针理论上可以解引用到任意数据类型

- 引用的解引用访问是受限的，只能解引用到它引用数据的类型，不能用作它用

即在 rust 中的引用是一个**受控**的**指针**，指向某个**特定的类型** 

因为如果可变引用实现了 Copy trait，那么生成一个可变引用然后把它赋值给另一个变量时，就会违背所有权规则：同一个作用域下只能有一个可变引用

### 引用的限制

1. 借用不能超过值的生存期
2. 不可以同时存在多个活跃的可变引用
3. 活跃的可变引用和不可变引用不可以同时存在
4. 引用的作用域从声明的地方开始一直持续到最后一次使用为止，而不是词法作用域结束，这种能力称之为**非词法作用域生命周期** 



