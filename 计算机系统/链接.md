## C 语言转换过程

用 GCC 编译器套件进行转换的过程：

1. 预处理：在高级语言源程序中插入所有用 `#include` 命令指定的文件和用 `#define` 声明指定的宏

2. 编译：将预处理后的源程序文件编译生成相应的汇编语言程序

3. 汇编：由汇编程序将汇编语言源程序文件转换为**可重定位的机器语言目标代码文件**

4. 链接：由**链接器**将多个可重定位的机器语言目标文件以及库例程（如 `printf` 库函数）链接起来，生成最终的**可执行目标文件**


![](https://oss.xiefeng.tech/images/20211026231522.png)

### 预处理

处理源文件中以“#”开头的预编译指令

- 删除 `#define` 并展开所定义的宏
- 处理所有条件预编译指令，如 `#if`、`#ifdef`、`#endif` 等
- 插入头文件到 `#include` 处，并递归的处理
- ......

使用 cpp 程序可以得到源文件预处理之后的结果，gcc 实际上是具体程序（如ccp、cc1、as等）的包装命令

```shell
$ cpp hello.c > hello.i
$ gcc –E hello.c –o hello.i
```

经过预编译处理后，得到的预处理文件还是一个可读的文本文件 ，但不包含任何的宏定义

### 编译

编译过程就是将预处理后得到的预处理文件进行词法分析、语法分析、语义分析，优化后生成汇编代码文件

使用 gcc 可以得到经过编译之后的文件

```shell
$ gcc –S hello.i –o hello.s
# 也可以直接通过源文件得到编译之后的文件
$ gcc –S hello.c –o hello.s
```

经过编译后，得到的汇编代码文件依旧是可读的文本文件，但是 CPU 无法理解和执行它

### 汇编

汇编程序用来将汇编语言源程序转换为机器指令序列

汇编结果是一个**可重定位目标文件**，其中包含的是不可读的二进制代码，必须用相应的工具软件来查看其内容

可以通过 as 程序进行汇编操作

```shell
$ gcc –c hello.c –o hello.o
$ gcc –c hello.s –o hello.o
$ as hello.s -o hello.o
```

### 链接

预处理、编译和汇编三个阶段针对一个模块进行处理，得到对应的一个可重定位目标文件

链接过程将多个可重定位目标文件合并以生成一个**可执行目标文件**

`–static` 表示执行静态链接操作

```shell
$ gcc –static –o myproc main.o test.o
$ ld –static –o myproc main.o test.o
```

## 链接

最早程序员用机器语言编写程序，并记录在纸带或卡片上，当增加或删除某一条指令时则，则需要修改其中的 jump 指令的目标地址，以及需要重新打孔，这是非常麻烦的

原始的链接概念早在高级编程语言出现之前就已存在，在使用汇编进行编程时往往会使用符号表示跳转和变量的位置，这样即使需要修改程序这些也不会受影响，只需要最终将符号替换为该符号定义的地址即可，这个替换过程就称为**链接**

链接可以带来一些好处

- 一个程序可以分成很多源程序文件，实现模块化
  - 可以构建公共的函数库
- 可以将源文件分开编译，最后将它们链接即可
  - 只需重新编译被修改的源程序文件，然后重新链接
- 源文件中无需包含共享库函数的源码，只要直接调用即可

## 目标文件

所谓的目标文件就是

最早的目标文件格式是自有格式，非标准的，标准的几种目标文件格式

- DOS操作系统(最简单) :COM格式，文件中仅包含代码和数据，且被加载到固定位置



## ELF 目标文件

ELF 称为可执行可链接（Executable and Linkable Format），ELF 文件具有两种视图，也就是说有两种不同的文件都采用该种格式

ELF 具有两种视图：

- 链接视图：可重定位目标文件
- 执行视图：可执行目标文件

### ELF头

ELF头位于文件的开始位置，它的主要目的是定位文件的其他部分

ELF32 header的类型定义为 [`elf32_hdr`](https://github.com/torvalds/linux/blob/master/include/uapi/linux/elf.h#L205)，ELF64 header 的类型定义为 [`elf64_hdr`](https://github.com/torvalds/linux/blob/master/include/uapi/linux/elf.h#L220)

通过 `readelf` 程序可以查看 EFL 文件的各部分信息

```shell
$ readelf -h hello.o
```

![](https://oss.xiefeng.tech/images/20211106183508.png)

### 链接视图

链接视图所对应的文件为**可重定位目标文件**，其中包含的内容为：

- ELF 头：位于文件的开始位置，主要目的是定位文件的其他部分
- 节（section）：程序编译后的代码和数据等信息都存储在各种节中
  - .text 节中存储的是编译后的代码部分（一条一条的指令）
  - .rodata 节中存储的是只读数据，如字符串字面量、switch 跳转表等
  - .data 节中存储的是已初始化的全局变量
  - .bss 节中存储的是未初始化全局变量
    - 在磁盘空间层面不存在该部分，该部分存在于逻辑上
    - 主要目的是优化空间效率，将初始化和未初始化的变量分开
  - .symtab 节：存放函数和全局变量（符号表）信息
  - .rel.text 节：.text 节的重定位信息，用于重新修改代码段的指令中的地址信息
  - .rel.data 节： .data节的重定位信息，用于对被模块使用或定义的全局变量进行重定位的信息
  - .debug 节：调试用符号表 (gcc -g)
  - strtab 节：包含 symtab 和 debug 节中符号及节名
- 节头表：存储了每个节的节名、偏移和大小











