

## 处理器模式

计算机一般设置0、1、2、3等四种运行模式，分别对应：

- 0 --- 操作系统内核
- 1 --- 系统调用
- 2 --- 共享库程序
- 3 --- 用户程序

计算机通过设置处理器模式实现特权指令管理，0 模式可以执行全部指令，3 模式只能执行非特权指令，其他每种运行模式可以规定执行的指令子集，一般来说，现代操作系统只使用0和3两种模式，对应于内核模式和用户模式。

**处理器模式的标记**

用程序状态字寄存器中的某个标志位来标识当前处理器的状态。

**处理器模式的切换**

包括“用户模式→内核模式”和“内核模式→用户模式”的转换

中断、异常或系统异常等事件导致用户程序向OS内核切换，OS内核处理完成后，调用中断返回指令，将 PSW 标志位设置为用户态

如果双重模式没有硬件支持，则操作系统会有严重缺点。例如，MS-DOS 是为了Intel 8088 体系结构而编写，没有模式位，因而没有双重模式。运行出错的程序可以通过写入数据而清除整个操作系统，多个程序可以同时写入同一设备，进而可能引起灾难结果。



## CPU工作模式

CPU 的工作模式有实模式、保护模式、长模式

CPU 的工作模式是指 CPU 的寻址方式、寄存器大小等用来反应 CPU 在该环境下如何工作的概念

### 实模式

在 8086/8088 时代，当时 CPU 的性能有限，只有 20 位地址线，8 个 16 位的通用寄存器，以及 4 个 16 位的段寄存器。

为了能够通过这些 16 位的寄存器去构成 20 位的主存地址，需要使用 `段基址 : 段偏移量` 这种格式来表示

**物理地址 = 段基址 << 4 + 段内偏移** 

从 80286 开始 CPU 增加了另外的操作模式，8086/8088 CPU 的这种模式被命名为**实地址模式** 

实模式用于保持向前兼容，保证后续的 CPU 能够运行旧的软件，实模式提供了 8086 的编程环境，采用 16 位寻址模式

80286 及以后所有的 x86 CPU 都是在**实模式下开机**，来确保传统操作系统的向前兼容性

- 由于偏移量使用 16 位来表示，访问超过 64KB 的内存便要修改段基址
- 只能使用 20 位地址线，最大可用内存只有 1M，我们把地址在 1M 以下的内存称为常规内存，1M 以上的内存称为扩展内存

所谓的实模式也就是**程序引用的地址都是真实的物理地址**，程序可随意修改自己的段基址，也可以任意访问和改变内存 

### 保护模式

保护模式同实模式的根本区别是**进程内存受保护与否**，可寻址空间的区别只是这一原因的果

在实模式下一般将整个物理内存看成分段的区域（程序代码和数据位于不同区域），系统程序和用户程序没有区别对待，而且程序所引用的都是实际的物理地址，如果用户程序的一个地址引用了系统程序区域或其他用户程序区域并改变了其值，那么对于这个被修改的系统程序或用户程序，其后果就很可能是灾难性的。

为了克服这种低劣的内存管理方式，处理器厂商开发出保护模式

在保护模式下，物理内存地址不能直接被程序访问，程序内部所引用的都是**虚拟地址**，要由操作系统将其转化为物理地址再去访问内存，并且程序对此是一无所知的。

在保护模式下进程之间就有了严格的边界，任何进程根本没有办法访问不属于自己的物理内存区域，甚至在自己的虚拟地址范围内也不是可以任意访问的，因为有一些虚拟区域已经被放进一些公共系统运行库。这些区域不能随便修改，若修改就会有: SIGSEGV（linux 段错误）；非法内存访问对话框（windows 对话框）。

在任何保护模式的特性可用前，必须要由某些程序手动地切换到保护模式，这通常是操作系统在开机时候必须完成的一个任务

保护模式下的寻址方式依旧采用 `段基址:段偏移量` 的方式，但是段寄存器不再直接指向段基址，而是通过**选择子**和 **GDT** 完成寻址

**全局描述符表**是保护模式下限制非法内存访问的一种方式，其条目描述规定了不同段的各种特征，包括基地址、大小和访问特权等

在保护模式下执行代码 `mov ds:[si], ax` 的大致步骤：

1. CPU 根据 GDTR 寄存器查找 GDT 在内存中位置
2. 根据 DS 寄存器找到 GDT 中目标段描述符的物理地址
3. 根据描述符中的段基址和 SI 寄存器存储的偏移量，计算出目标物理地址
4. 将 AX 寄存器中的数据写入到目标物理地址







扩充的存储器分段管理机制和可选的存储器分页管理机制，不仅为存储器共享和保护提供了硬件支持，而且为实现虚拟存储器提供了硬件支持; 支持多任务，能够快速地进行任务切换和保护任务环境; 4个特权级和完善的特权检查机制，既能实现资源共享又能保证代码和数据的安全和保密及任务的隔离; 支持虚拟8086方式，便于执行8086程序



> **全局描述符表** **(GDT)** 是一个从 Intel x86-系列处理器 80286 开始用于界定不同内存区域的特征的数据结构。 全局描述表位于内存中。全局描述表的条目描述及规定了不同内存分区的各种特征，包括基地址、大小和访问等特权如可执行和可写等。 在 Intel 的术语中，这些内存区域被称为 *段* 。
>
> 全局描述表用于内存地址的转换。所有程序的内存访问都需要用到 GDT 中的有关内存区域即 x86 内存分段的信息。访问 GDT 需要使用segment selector和segment offset。处理器使用 segment selector 为索引查找 GDT 的条目。当适当的条目找到后，处理器将会做一系列的检查，包括检查 segment offset 尝试访问区间是否在此内存分段内，代码是否有权限访问此内存分段(检查分级保护域权限）等。
>
> 为了加速全局描述表的访问，往segment寄存器里载入segment的值会使得GDT的特定条目被读入处理器内部的缓存中。之后的内存访问将会通过缓存进行处理。
>
> [全局描述符表](https://www.wikiwand.com/zh-hans/%E5%85%A8%E5%B1%80%E6%8F%8F%E8%BF%B0%E7%AC%A6%E8%A1%A8)

## GDT

由于实模式下寻址的方式是不安全的，所以在保护模式下寻址时对于每个内存段都需要加一些限制

我们把这些关于内存段的限制信息放在一个叫做**全局描述符表（GDT）**的结构里，GDT 是保护模式下限制非法内存访问的一种方式。

GDT 可以存放在内存中的任意位置，使用专门的寄存器 **GDTR** 指定给 CPU

在CPU 切换到保护模式**前**就需要准备好 GDT 并执行 `LGDT` 指令将 GDT 的**基地址**和**界限**传给 GDTR，所以 GDT 一般都定义在 1MB 以下的内存中，当然也允许在进入保护模式后换个位置重新定义 GDT

GDTR 是一个 48 位的寄存器，存储着 GDT 的内存地址及大小：

- 32 位的线性基地址：GDT在内存中的起始线性地址
- 16 位的表界限：在数值上等于表的大小（总字节数）减去1

![](http://img.blog.csdn.net/20160109121106894)

在处理器刚上电的时候，基地址默认为 0，表界限默认为 0xFFFF， 在保护模式初始化过程中，必须给 GDTR 加载一个新值。

因为表界限是16位的，最大值是 0xFFFF（65535）那么表的大小就是 65535+1=65536

因为一个描述符占用 8 个字节，所以 65536 字节相当于 8192 个描述符（65536/8=8192）

故理论上最多可以定义 8192 个描述符，实际上不一定这么多，具体多少根据需要而定

### 段描述符

GDT 中的每一个表项称为**段描述符**，GDT 的数据结构本质上就是一个**段描述符数组** 

段描述符中存放了段基址、段界限、内存段类型属性（比如是数据段还是代码段，**一个段描述符只能用来定义一个内存段**）等属性

![](/Users/xiefeng/Library/Application Support/typora-user-images/image-20220319155846199.png)

每个描述符占据 8 个字节，包含三个部分：

- 段基址：总共 32 位，占据描述符的第16～39位和第55位～63位，前者存储低16位，后者存储高16位
- 段界限：总共 20 位，占据描述符的第0～15位和第48～51位，前者存储低16位，后者存储高4位。
- 段属性：总共 12 位，占据描述符的第39～47位和第49～55位

段属性可以细分为 8 种：TYPE 属性、S 属性、DPL 属性、P 属性、AVL 属性、L 属性、D/B 属性和 G 属性

S属性存储了描述符的类型：

- S = 0 时，该描述符对应的段是**系统段 ** 
- S = 1 时，该描述符对应的段是**数据段或者代码段** 

TYPE 属性存储段的类型信息，该属性的意义随着S属性不同而不同：

DPL 属性占 2 个比特，记录了访问段所需要的特权级，特权级范围为 0～3，越小特权级越高

P 属性标记了该段是否存在，尝试访问一个在内存中不存在的段会触发段不存在错误

- P = 0 时，该段在内存中不存在
- P = 1 时，该段在内存中存在

[x86保护模式——全局描述符表GDT详解](https://blog.csdn.net/abc123lzf/article/details/109289567) 

[全局描述符表GDT中一般存放有那些描述符？](https://www.zhihu.com/question/402572123) 

### 选择子

段寄存器（CS、 DS、 ES、 FS、 GS、 SS）在实模式下时存储的是段基地址，即内存段的起始地址。 

而在保护模式下，段基址已经存入了段描述符中，再存放段基址是没有意义的，所以段寄存器中存放的是**选择子** 

选择子**“基本上”**是个索引值，但是段选择子不仅仅只表明位置

选择子实际上指明了：段描述符的索引值、查哪一张表（GDT/LDT）、请求特权级

![](/Users/xiefeng/Library/Application Support/typora-user-images/image-20220321142550772.png)

LDT（局部描述符表）是 CPU 厂商为了在硬件层级上原生支持多任务而创建的表，按其设想一个任务对应一个 LDT，切换任务时也要切换 LDT，现代操作系统很少有使用 LDT 的。

### 段权限检查

x86 架构下定义了4个特权级：0~3，0 特权级最高，3 特权级最低

- DPL：Descriptor Privilege Level，段描述特权级别，待访问的数据段或代码段描述符的 DPL 位域（45 位与 46位）
- CPL：Current Privilege Level，当前特权级别，也就是当前运行代码段段选择子 CS 的 RPL 位域

- RPL：Request Privilege Level，请求特权级别，段选择子的后两位（待访问的代码段或数据段段选择子的 RPL 位域）

DPL 存储在段描述符中，规定访问该段的权限级别，每个段的 DPL 固定。

CPL 是当前正在执行的指令所在的段的特权级（当前进程的权限级别），通常情况下 CPL 等于指令所在的段的特权级（DPL）。

RPL 是对于**段选择子**而言的，它说明的是进程对该段访问的**请求权限**（由当前进程决定），RPL 对每个段来说不是固定的

RPL 可以削弱 CPL 的作用，例如 CPL=0 的进程要访问一个数据段，它把 RPL 设为 3，这样它对该段只有特权为 3 的访问权限

RPL 可以由当前进程随便写，代表了当前进程的**意愿**，是否实现还有待 CPU 的许可（CPU 会同时检查 RPL 和 CPL）

采用 RPL 是考虑到安全的问题：

- 就好像你明明对一个文件有写权限，却使用只读打开它
- 操作系统往往用 RPL 来避免低特权级程序访问高特权级段内的数据（通过委托高特权级程序）

> RPL 能够用来确保具有特权级的代码不会代表另一个应用程序去访问一个段，除非那个应用程序具有访问那个段的权限

更多关于 RPL 非常形象的举例： [Orange'S：一个操作系统的实现 ---- 保护模式-特权级](https://dbb4560.github.io/2019/10/29/Orange'S-%E4%B8%80%E4%B8%AA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%AE%9E%E7%8E%B0-%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F%E7%89%B9%E6%9D%83%E7%BA%A7/) 

**当进程访问一个段时，需要进行特权级检查，一般要求 DPL >= max { CPL, RPL }** 

#### 一致性代码段

简单理解就是操作系统拿出来被共享的代码段，可以被低特权级的用户直接调用访问的代码。

通常这些共享代码，是"不访问"受保护的资源和某些类型异常处理，比如一些数学计算函数库。

访问一致性代码段，要求 CPL ≥ DPL，不检查 RPL

即低特权级的代码可以访问高特权级的代码，但 CPL 保持不变。这是唯一的CPL和DPL可以不相等的情况。

#### 非一致性代码段

为了避免低特权级的访问而被操作系统保护起来的系统代码

访问非一致性代码段，要求 `CPL = DPL && RPL ≤ CPL`，同时 CPL 保持不变

![](/Users/xiefeng/Library/Application Support/typora-user-images/image-20220322171024775.png)

[x86权限比较规则（CPL/DPL/RPL](https://blog.csdn.net/baidu_31504167/article/details/100762630) 

[段使用时相关的检查与调用门实验](https://blog.csdn.net/youyou519/article/details/89547022) 

[保护模式4-段权限检查](https://www.404bugs.com/details/911783753026424832) 

## OS的启动

操作系统启动过程简单分为四部分：BIOS 自检、系统引导、启动内核、初始化系统

以 x86 CPU 为例

1. x86 CPU 加电后从 `0xFFFF0` 处开始执行（**ROM BIOS** 的映射区）
   - 此时 CPU 处于**实模式**，CS=0xFFFF，IP=0x0000，也有 CS=0xF000，IP=0xFFF0 的说法
   - 8086 CPU 中的 EPROM（BIOS 的代码固化在里面） 被编址在 1ＭB 内存地址空间的最高 64KB 中
   - 这里存放的是一条长跳转指令 `JMP F000:E05B`，指向 BIOS 中真正的启动代码
   - 到了 32 位的 80386 CPU时代，BIOS ROM 依旧编址在 32 位内存地址空间的最后一个 64KB
     - 如果 BIOS 的编址不变，会把整个物理内存地址空间隔离成不连续的两段，这很不协调
     - 系统开机复位时 CS 和 IP 保持不变，利用硬件设计（[shadow register](https://www.google.com.hk/search?q=shadow+register+%E6%98%AF%E4%BB%80%E4%B9%88&oq=shadow+register+%E6%98%AF%E4%BB%80%E4%B9%88&aqs=chrome..69i57j33i160.2752j0j1&sourceid=chrome&ie=UTF-8)和映射机制）达成向后兼容 8086
     - 参考文章：
       - https://chyyuu.gitbooks.io/ucore_os_docs/content/lab1/lab1_3_1_bios_booting.html
       - http://www.360doc.com/content/16/1018/17/19227797_599395314.shtml
2. BIOS 执行硬件自检（Power-On Self-Test，缩写为 POST），检查 RAM，键盘，显示器，软硬磁盘等硬件
   - 目的是检查计算机硬件能否满足运行的基本条件
   - 如果硬件出现问题，主板会发出不同含义的蜂鸣，启动中止
   - 同时系统 BIOS 也会去查找其它设备的 BIOS，分别调用它们的初始化代码来初始化设备
3. BIOS 按照**启动顺序**把控制权转交给排在第一位的储存设备
   - 启动顺序以及其他的一些系统配置都保存在主板上的 [CMOS](https://www.wikiwand.com/zh-cn/%E4%BA%92%E8%A3%9C%E5%BC%8F%E9%87%91%E5%B1%AC%E6%B0%A7%E5%8C%96%E7%89%A9%E5%8D%8A%E5%B0%8E%E9%AB%94) 中
   - BIOS 读取该设备的第一个扇区（512 bytes）到内存的 **0x7c00** 处
     - 该区域叫做**主引导记录**（Master boot record，缩写为 MBR），这个扇区称为**“主引导扇区”**
     - MBR 的最后两个字节是 0x55 和 0xAA，则表明这个设备可以用于启动
     - 对于磁盘来说就是 0 磁道 0 扇区
   - 接着设置 **CS=0x07c0**，**IP=0x0000**，开始执行引导扇区的代码

MBR 只有 512 Bytes，放不了太多东西，它的主要作用是加载操作系统。

MBR 由三个部分组成：

1. 第1-446字节：调用操作系统的机器码
2. 第447-510字节：分区表（Partition table）
3. 第511-512字节：主引导记录签名（0x55和0xAA）

https://www.initroot.com/linuxintroduction/computerbootprocess.html

https://www.ruanyifeng.com/blog/2013/02/booting.html

硬盘的第一个扇区上存放着开机后执行的第一段我们可以控制的程序（操作系统的引导程序）

以 linux0.11 为例，**bootsect.s** 为存放在引导扇区的代码

1. 为了方便加载主模块，引导程序首先会将自己移动到内存相对靠后的位置（linux0.11 的 bootsect.s 就先将自己移动到 0x90000 处）
2. 接着跳转到 0x90000 处开始执行，会利用 BIOS 0x13 中断将 setup 和 system 模块的代码读入内存
3. 接着跳转到 setup 模块完成 OS 启动前的设置

**setup.s** 主要完成的一些设置

1. 获取光标、内存、显卡等硬件的参数存放在 0x90000 开始的地方
2. 将 os 主模块代码移动到 0x00000 处
3. 设置 idt 和 gdt，让 CPU 进入保护模式
4. 跳转到内存 0x00000 处开始执行 system 模块代码

## 系统调用

**操作系统接口**用于连接应用软件和操作系统，本质上是 OS 提供的一些函数，接口的使用则通过函数调用，所以称为**系统调用** 

实现系统调用需要将内核程序和用户程序**隔离**，实现隔离需要处理器的**硬件设计**，

系统调用提供操作系统服务接口，系统调用为用户程序提供手段，以便请求操作系统完成某些特权指令。系统调用通常会陷入中断向量的某个指定位置。一般由通用 trap（陷入）指令来完成。当要执行系统调用时，硬件通常将其作为软中断，控制通过中断向量转到操作系统的中断服务程序，并且模式位也设置为内核模式。

陷入指令是唯一一个只能在用户态执行，而不能在核心态执行的指令。

对于大多数的程序设计语言，运行时支持系统提供了系统调用接口，以链接到操作系统的系统调用。系统调用接口接口截取 API 函数的调用，并调用操作系统中所需系统调用。通常，每个系统调用都有一个相关数字，而系统调用接口会分局这些数字来建立一个索引列表。系统调用接口可调用操作系统内核中的所系统调用，并返回系统调用状态和返回值。

向操作系统传递参数的方式：

1. 通过寄存器，但是参数可能会比寄存器多
2. 参数存在内存中，内存地址通过寄存器传递
3. 参数压入堆栈中，通过操作系统 pop
