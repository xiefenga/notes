## CPU工作原理

冯诺依曼式计算机采用**存储程序**的工作方式，数据和指令事先存放在存储器中，形式上没有差别

每条指令和每个数据都有各自的地址，其中指令按序存放，PC 中存放着程序下一条需要执行指令的地址，指令由 OP、ADDR 字段组成

CPU 能自动地取出一条一条指令执行无需人为干预，指令和数据被从存储器取到 CPU，存放在寄存器中，其中指令在 IR 中，数据在通用寄存器中

CPU 执行指令的一般步骤：

1. 从 PC 指向的地址中取出指令
2. 修改 PC 的值，指向下一条指令
3. 对指令进行译码
4. 执行该条指令

## 指令集体系结构

指令集体系结构（ISA）是一种规约，它规定了如何使用硬件

- 所有**可执行指令的集合**
- 指令格式、操作种类以及每种操作对应的操作数的相应规定
- 指令可以接受的操作数的类型
- 操作数所能存放的寄存器组的结构，包括每个寄存器的名称、编号、 长度和用途
- 操作数所能存放的存储空间的大小和编址方式
- 操作数在存储空间存放时按照大端还是小端方式存放
- 指令获取操作数的方式，即寻址方式
- 指令执行过程的控制方式，包括程序计数器、条件码定义等

ISA 在计算机系统中是必不可少的一个**抽象层**，缺少 ISA 软件无法使用计算机硬件，一台计算机也不能称为“通用计算机“

ISA 和计算机组成（微体系结构）的关系：ISA 是计算机组成的抽象，同一种 ISA 可以有不同的计算机组成

相当于 ISA 规定了接口，计算机组成是具体的实现方式，实现方式是不唯一的，例如：乘法指令可用 ALU 或乘法器实现

## C 语言转换过程

用 GCC 编译器套件进行转换的过程：

1. 预处理：在高级语言源程序中插入所有用 `#include` 命令指定的文件和用 `#define` 声明指定的宏

2. 编译：将预处理后的源程序文件编译生成相应的汇编语言程序

3. 汇编：由汇编程序将汇编语言源程序文件转换为**可重定位的机器语言目标代码文件**

4. 链接：由**链接器**将多个可重定位的机器语言目标文件以及库例程（如 `printf` 库函数）链接起来，生成最终的**可执行目标文件**


![](https://oss.xiefeng.tech/images/20211026231522.png)

## x86 架构

x86 是 Intel 开发的一类处理器体系结构的泛称，包括 Intel 8086、80286、i386 和 i486 等，因此其架构被称为 “x86”

Intel 把 32 位 x86 架构的名称 x86-32 改称为 IA-32，IA 是 Intel Architecture 的缩写

兼容 IA-32 指令集的 64 位版本：

- 命名为 “x86-64” ，有时也简称为 x64

- AMD 首先提出，并称其为 AMD64
- Intel 称其为 Intl64

IA-32 架构由16位架构发展而来，虽然字长为32 位或更大 ，但一个字固定为 16 位，长度后缀为 w，32 位为双字，长度后缀为 l

## 过程调用

过程调用在使用机器级指令的一般执行步骤（P为调用者，Q为被调用者）

1. P 保存被调用函数所需的参数，并且 Q 能够访问到这些参数
2. P 保存调用完成后的返回地址，然后控制转移到 Q
3. Q 保存 P的现场（将自己需要用到的寄存器入栈）
4. 执行 Q 的过程体（函数体），为自己的局部变量分配空间
5. Q 恢复 P 的现场，释放过程占用的内存空间
6. Q 取出返回地址，并将控制转移到 P

核心是需要**保护现场**和**恢复现场**，本质的原因是所有过程**共享一套通用寄存器**

参数的传递可以通过寄存器，也可以通过栈，主要还是看寄存器和参数的数量

### 栈和栈帧

CPU 往往会提供栈操作的指令，主要是通过栈顶指针寄存器指示当前栈顶的位置，通过修改栈顶指针寄存器的值来实现入栈和出栈的操作

一个过程的调用会在栈中压入一个栈帧，栈帧本质上就是栈中的一块内存空间，其中存储了该过程调用中所有的局部变量和可能需要传递的参数，以及对父过程现场的保护（寄存器）

在可执行文件中存在一部分的空间分配给栈（往往栈顶在低地址部分，栈底在高地址部分），用于实现一个一个的过程调用

![](https://oss.xiefeng.tech/images/20211028220624.png)

所谓的栈还是存在于逻辑上，在内存的层面上不存在栈这种结构，只是通过栈的方式去操作内存去达到这种数据结构的特点

栈帧在不同的角度是不同的，通过 `push` 指令去入栈，那么栈帧意味着就是一个存储单元（字节）或者一个字等大小

而在过程调用的角度，一个栈帧就是一个过程调用所占用的内存大小，在 IA-32 往往通过 EBP 和 ESP 寄存器来表示栈顶的栈帧

在 x86-64 由于地址是 64 bit 的，所以使用 rbp 和 rsp 寄存器来表示当前过程调用的栈帧

### 机器级表示

```c
int add(int x, int y) {
  return  x + y;
}

int caller() {
  int t1 = 125, t2 = 80;
  int sum = add(t1, t2);
  return sum;
}
```

可以将源码编译之后再反汇编，查看相关的过程调用指令

```shell
gcc -o process_call process_call.c && objdump -d process_call > process_call.s
```

在 x86_64-redhat-linux 环境下进行编译，使用 objdump 可以得到该程序 `caller` 函数所对应的汇编指令

![](https://oss.xiefeng.tech/images/20211104191221.png)

## 数据对齐

在读写数据时主存按一个**传送单位**（字长）进行传输，这意味着如果传送单位为 64 位，则第 0~7 字节同时读写，第 8~15 字节同时读写

而内存按字节编址，所以如果要读取 `0x7 ~ 0x8` 这两个内存单元，则需要进行两次访存

指令系统支持对字节、半字、字及双字的运算，所以为了提高效率，编译器会让各种不同长度的数据存放时**按边界对齐**

以 32 位系统为例，不同系统采用的内存对齐策略有些许差别

- Windows 采用策略

  - char 型无需对齐
  - int 型地址是 4 的倍数、short 型地址是2 的倍数
  - float 型的是4 的倍数、double 和 long long 型的是8的倍数
- Linux采用更宽松策略
  - short 型是2的倍数
  - 其他类型如 int、 float、double 和指针等都是 4 的倍数

对于结构来说，**结构变量首地址**按 4 字节边界对齐，结构数组变量的最末可能需要插空，以使每个数组元素都按 4 字节边界对齐

对于成员相同的两个结构，两者所占用的空间并不相同：

```c
struct c1 {
  int i;
  char c;
  int j;
};

struct c2 {
  int i;
  int j;
  char c;
};
```

![](https://oss.xiefeng.tech/images/20211104193712.png)













